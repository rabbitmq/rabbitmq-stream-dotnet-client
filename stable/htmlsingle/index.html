<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.22">
<title>RabbitMQ Stream .Net Client</title>
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import url("//fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700");*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
body{-webkit-font-smoothing:antialiased}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
body{tab-size:4}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^=";http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}

</style>
<style>
/*! Stylesheet for CodeRay to loosely match GitHub themes | MIT License */
pre.CodeRay{background:#f7f7f8}
.CodeRay .line-numbers{border-right:1px solid;opacity:.35;padding:0 .5em 0 0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
.CodeRay span.line-numbers{display:inline-block;margin-right:.75em}
.CodeRay .line-numbers strong{color:#000}
table.CodeRay{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.CodeRay td{vertical-align:top;line-height:inherit}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.code{padding:0 0 0 .75em}
.CodeRay .debug{color:#fff!important;background:navy!important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:navy}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:teal}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:teal}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:teal}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword{color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:teal}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>RabbitMQ Stream .Net Client</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_what_is_a_rabbitmq_stream">What is a RabbitMQ Stream?</a></li>
<li><a href="#_when_to_use_rabbitmq_stream">When to Use RabbitMQ Stream?</a></li>
<li><a href="#_other_way_to_use_streams_in_rabbitmq">Other Way to Use Streams in RabbitMQ</a></li>
<li><a href="#_guarantees">Guarantees</a></li>
<li><a href="#stream-client-overview">Stream Client Overview</a></li>
<li><a href="#stability-of-programming-interfaces">Stability of Programming Interfaces</a></li>
<li><a href="#stream-client-usage">The Stream .NET Client</a>
<ul class="sectlevel2">
<li><a href="#_setting_up_rabbitmq">Setting up RabbitMQ</a>
<ul class="sectlevel3">
<li><a href="#_with_docker">With Docker</a>
<ul class="sectlevel4">
<li><a href="#_with_docker_bridge_network_driver">With Docker Bridge Network Driver</a></li>
<li><a href="#_with_docker_host_network_driver">With Docker Host Network Driver</a></li>
</ul>
</li>
<li><a href="#_with_a_rabbitmq_package_running_on_the_host">With a RabbitMQ Package Running on the Host</a></li>
</ul>
</li>
<li><a href="#_dependencies">Dependencies</a></li>
<li><a href="#_sample_application">Sample Application</a></li>
<li><a href="#rabbitmq-stream-net-api">RabbitMQ Stream .NET API</a>
<ul class="sectlevel3">
<li><a href="#_overview">Overview</a></li>
<li><a href="#_streamsystem">StreamSystem</a>
<ul class="sectlevel4">
<li><a href="#_creating_the_streamsystem">Creating the StreamSystem</a></li>
<li><a href="#understanding-connection-logic">Understanding Connection Logic</a></li>
<li><a href="#_enabling_tls">Enabling TLS</a></li>
<li><a href="#_configuring_the_stream_system">Configuring the Stream System</a></li>
<li><a href="#connection-pool">Connection pool</a></li>
<li><a href="#address-resolver">When a Load Balancer is in Use</a></li>
<li><a href="#_managing_streams">Managing Streams</a></li>
</ul>
</li>
<li><a href="#creating-a-producer">Producer</a>
<ul class="sectlevel4">
<li><a href="#_creating_a_producer">Creating a Producer</a></li>
<li><a href="#_sending_messages">Sending Messages</a></li>
<li><a href="#working-with-complex-messages">Working with Complex Messages</a></li>
<li><a href="#outbound-message-deduplication">Message Deduplication</a>
<ul class="sectlevel5">
<li><a href="#_use_deduplicationproducer">Use DeduplicationProducer</a></li>
<li><a href="#_understanding_publishing_id">Understanding Publishing ID</a></li>
<li><a href="#_restarting_a_producer_where_it_left_off">Restarting a Producer Where It Left Off</a></li>
</ul>
</li>
<li><a href="#sub-entry-batching-and-compression">Sub-Entry Batching and Compression</a></li>
</ul>
</li>
<li><a href="#creating-a-consumer">Consumer</a>
<ul class="sectlevel4">
<li><a href="#_creating_a_consumer">Creating a Consumer</a></li>
<li><a href="#crc-on-delivery">Check the CRC on Delivery</a></li>
<li><a href="#specifying-an-offset">Specifying an Offset</a></li>
<li><a href="#consumer-offset-tracking">Tracking the Offset for a Consumer</a>
<ul class="sectlevel5">
<li><a href="#consumer-manual-offset-tracking">Manual Offset Tracking</a></li>
<li><a href="#_considerations_on_offset_tracking">Considerations On Offset Tracking</a></li>
</ul>
</li>
<li><a href="#single-active-consumer">Single Active Consumer</a>
<ul class="sectlevel5">
<li><a href="#_enabling_single_active_consumer">Enabling Single Active Consumer</a></li>
<li><a href="#_offset_tracking">Offset Tracking</a></li>
<li><a href="#consumer-update-listener">Reacting to Consumer State Change</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#entity-status">Producer/Consumer change status callback</a></li>
<li><a href="#low-high-level-classes">Low Level and High Level classes</a>
<ul class="sectlevel4">
<li><a href="#_low_level_classes">Low-level classes</a></li>
<li><a href="#_high_level_classes">High-level classes</a></li>
</ul>
</li>
<li><a href="#_query_streamsuperstream">Query Stream/SuperStream</a></li>
<li><a href="#super-streams">Super Streams (Partitioned Streams)</a>
<ul class="sectlevel4">
<li><a href="#_topology">Topology</a></li>
<li><a href="#_super_stream_creation">Super Stream Creation</a></li>
<li><a href="#super-stream-producer">Publishing to a Super Stream</a>
<ul class="sectlevel5">
<li><a href="#_resolving_routes_with_bindings">Resolving Routes with Bindings</a></li>
<li><a href="#super-stream-deduplication">Deduplication</a></li>
</ul>
</li>
<li><a href="#_consuming_from_a_super_stream">Consuming From a Super Stream</a>
<ul class="sectlevel5">
<li><a href="#super-stream-consumer-in-practice">Super Stream Consumer in Practice</a></li>
<li><a href="#_declaring_a_super_stream_consumer">Declaring a Super Stream Consumer</a></li>
<li><a href="#_offset_tracking_2">Offset Tracking</a></li>
<li><a href="#super-stream-sac">Single Active Consumer Support</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#super-stream-sac-full-example">Super Stream with Single Active Consumer Example</a></li>
</ul>
</li>
<li><a href="#_advanced_topics">Advanced Topics</a>
<ul class="sectlevel3">
<li><a href="#_filtering">Filtering</a>
<ul class="sectlevel4">
<li><a href="#_filtering_on_the_publishing_side">Filtering on the Publishing Side</a></li>
<li><a href="#_filtering_on_the_consuming_side">Filtering on the Consuming Side</a></li>
<li><a href="#_considerations_on_filtering">Considerations on Filtering</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_deal_with_broker_disconnections_reconnections_and_metadata_update_events">Deal with broker disconnections, reconnections and metadata update events</a></li>
<li><a href="#_update_secret">Update Secret</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The RabbitMQ Stream .Net Client is a .Net library to communicate with
the <a href="https://rabbitmq.com/stream.html">RabbitMQ Stream Plugin</a>.
It allows creating and deleting streams, as well as publishing to and consuming from
these streams. Learn more in the <a href="#stream-client-overview">the client overview</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_a_rabbitmq_stream">What is a RabbitMQ Stream?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A RabbitMQ stream is a persistent and replicated data structure that models
an <a href="https://en.wikipedia.org/wiki/Append-only">append-only log</a>. It differs from the classical
RabbitMQ queue in the way message consumption works. In a classical RabbitMQ queue,
consuming removes messages from the queue. In a RabbitMQ stream, consuming leaves
the stream intact. So the content of a stream can be read and re-read without
impact or destructive effect.</p>
</div>
<div class="paragraph">
<p>None of the stream or classical queue data structure is better than the other,
they are usually suited for different use cases.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_when_to_use_rabbitmq_stream">When to Use RabbitMQ Stream?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RabbitMQ Stream was developed to cover the following messaging use cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Large fan-outs:</em> when several consumer applications need to read the same messages.</p>
</li>
<li>
<p><em>Replay / Time-traveling:</em> when consumer applications need to read the whole
history of data or from a given point in a stream.</p>
</li>
<li>
<p><em>Throughput performance:</em> when higher throughput than with other protocols
(AMQP, STOMP, MQTT) is required.</p>
</li>
<li>
<p><em>Large logs:</em> when large amount of data need to be stored, with minimal
in-memory overhead.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_other_way_to_use_streams_in_rabbitmq">Other Way to Use Streams in RabbitMQ</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is also possible to use the stream abstraction in RabbitMQ
with the AMQP 0-9-1 protocol. Instead of consuming from a stream
with the stream protocol, one consumes from a "stream-powered" queue with
the AMQP 0-9-1 protocol. A "stream-powered" queue is a special type of queue that
is backed up with a stream infrastructure layer and adapted to
provide the stream semantics (mainly non-destructive reading).</p>
</div>
<div class="paragraph">
<p>Using such a queue has the advantage to provide the features
inherent to the stream abstraction (append-only structure, non-destructive
reading) with any AMQP 0-9-1 client library. This is clearly
interesting when considering the maturity of AMQP 0-9-1 client libraries
and the ecosystem around AMQP 0-9-1.</p>
</div>
<div class="paragraph">
<p>But by using it, one does not benefit from the performance
of the stream protocol, which has been designed for performance in mind,
whereas AMQP 0-9-1 is a more general-purpose protocol.</p>
</div>
<div class="paragraph">
<p>See also <a href="https://www.rabbitmq.com/stream-core-plugin-comparison.html">stream-core stream-plugin comparison</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_guarantees">Guarantees</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RabbitMQ stream provides at-least-once guarantees thanks to the
publisher confirm mechanism, which is supported by the stream .NET client.</p>
</div>
<div class="paragraph">
<p>Message <a href="#outbound-message-deduplication">deduplication</a>
is also supported on the publisher side.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="stream-client-overview">Stream Client Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The RabbitMQ Stream .NET Client implements the
<a href="https://github.com/rabbitmq/rabbitmq-server/blob/v3.10.x/deps/rabbitmq_stream/docs/PROTOCOL.adoc">RabbitMQ Stream protocol</a>
and avoids dealing with low-level concerns by providing high-level functionalities
to build fast, efficient, and robust client applications.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>administrate streams (creation/deletion) directly from applications.</em> This
can also be useful for development and testing.</p>
</li>
<li>
<p><em>adapt publishing throughput</em> thanks to the configurable batch size and flow control.</p>
</li>
<li>
<p><em>avoid publishing duplicate messages</em> thanks to message deduplication.</p>
</li>
<li>
<p><em>consume asynchronously from streams and resume where left off</em> thanks to
manual offset tracking.</p>
</li>
<li>
<p><em>enforce <a href="https://blog.rabbitmq.com/posts/2021/07/connecting-to-streams/">best practices</a> to create client connections</em> â€“ to stream leaders for publishers to minimize inter-node traffic and to stream replicas for consumers to offload leaders.</p>
</li>
<li>
<p><em>let the client handle network failure</em> thanks to automatic connection
recovery and automatic re-subscription for consumers.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="stability-of-programming-interfaces">Stability of Programming Interfaces</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The client contains 2 sets of programming interfaces whose stability are of interest for application developers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Application Programming Interfaces (API): those are the ones used to write application logic. They include the interfaces and classes in the <code>RabbitMQ.Stream.Client.Reliable</code> package (e.g. <code>Producer</code>, <code>Consumer</code>, <code>Message</code>). These API constitute the main programming model of the client and will be kept as stable as possible.</p>
</li>
<li>
<p>Stream compression interface: <code>RabbitMQ.Stream.Client.ICompressionCodec</code>  and <code>RabbitMQ.Stream.Client.StreamCompressionCodecs</code> are used to implement custom compression codecs.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="stream-client-usage">The Stream .NET Client</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The library requires .NET 6 or .NET 7.</p>
</div>
<div class="sect2">
<h3 id="_setting_up_rabbitmq">Setting up RabbitMQ</h3>
<div class="paragraph">
<p>A RabbitMQ 3.9+ node with the stream plugin enabled is required. The easiest way
to get up and running is to use Docker.</p>
</div>
<div class="sect3">
<h4 id="_with_docker">With Docker</h4>
<div class="paragraph">
<p>There are different ways to make the broker visible to the client application when running
in Docker. The next sections show a couple of options suitable for local development.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Docker on macOS</div>
<div class="paragraph">
<p>Docker runs on a virtual machine when using macOS, so do not expect high performance
when using RabbitMQ Stream inside Docker on a Mac.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_with_docker_bridge_network_driver">With Docker Bridge Network Driver</h5>
<div class="paragraph">
<p>This section shows how to start a broker instance for local development
(the broker Docker container and the client application are assumed to run on the
same host).</p>
</div>
<div class="paragraph">
<p>The following command creates a one-time Docker container to run RabbitMQ:</p>
</div>
<div class="listingblock">
<div class="title">Running the stream plugin with Docker</div>
<div class="content">
<pre>docker run -it --rm --name rabbitmq -p 5552:5552 \
    -e RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS='-rabbitmq_stream advertised_host localhost' \
    rabbitmq:3.11</pre>
</div>
</div>
<div class="paragraph">
<p>The previous command exposes only the stream port (5552), you can expose
ports for other protocols:</p>
</div>
<div class="listingblock">
<div class="title">Exposing the AMQP 0.9.1 and management ports:</div>
<div class="content">
<pre>docker run -it --rm --name rabbitmq -p 5552:5552 -p 5672:5672 -p 15672:15672 \
    -e RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS='-rabbitmq_stream advertised_host localhost' \
    rabbitmq:3.11-management</pre>
</div>
</div>
<div class="paragraph">
<p>Refer to the official <a href="https://hub.docker.com/_/rabbitmq">RabbitMQ Docker image web page</a>
to find out more about its usage.</p>
</div>
<div class="paragraph">
<p>Once the container is started, <strong>the stream plugin must be enabled</strong>:</p>
</div>
<div class="listingblock">
<div class="title">Enabling the stream plugin:</div>
<div class="content">
<pre>docker exec rabbitmq rabbitmq-plugins enable rabbitmq_stream</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_with_docker_host_network_driver">With Docker Host Network Driver</h5>
<div class="paragraph">
<p>This is the simplest way to run the broker locally.
The container uses the <a href="https://docs.docker.com/network/host/">host network</a>,
this is perfect for experimenting locally.</p>
</div>
<div class="listingblock">
<div class="title">Running RabbitMQ Stream with the host network driver</div>
<div class="content">
<pre>docker run -it --rm --name rabbitmq --network host rabbitmq:3.11</pre>
</div>
</div>
<div class="paragraph">
<p>Once the container is started, <strong>the stream plugin must be enabled</strong>:</p>
</div>
<div class="listingblock">
<div class="title">Enabling the stream plugin:</div>
<div class="content">
<pre>docker exec rabbitmq rabbitmq-plugins enable rabbitmq_stream</pre>
</div>
</div>
<div class="paragraph">
<p>The container will use the following ports: 5552 (for stream) and 5672 (for AMQP.)</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Docker Host Network Driver Support</div>
<div class="paragraph">
<p>The host networking driver <strong>only works on Linux hosts</strong>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_with_a_rabbitmq_package_running_on_the_host">With a RabbitMQ Package Running on the Host</h4>
<div class="paragraph">
<p>Using a package implies installing Erlang.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Make sure to use <a href="https://github.com/rabbitmq/rabbitmq-server/releases">RabbitMQ 3.9 or more</a>.</p>
</li>
<li>
<p>Follow the steps to
<a href="https://rabbitmq.com/download.html">install Erlang and the appropriate package</a></p>
</li>
<li>
<p>Enable the plugin <code>rabbitmq-plugins enable rabbitmq_stream</code>.</p>
</li>
<li>
<p>The stream plugin listens on port 5552.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Refer to the <a href="https://rabbitmq.com/stream.html">stream plugin documentation</a> for more information on configuration.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dependencies">Dependencies</h3>
<div class="paragraph">
<p>The client is distributed via <a href="https://www.nuget.org/packages/RabbitMQ.Stream.Client/">NuGet</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sample_application">Sample Application</h3>
<div class="paragraph">
<p>This section covers the basics of the RabbitMQ Stream .NET API by building
a small publish/consume application. This is a good way to get
an overview of the API.</p>
</div>
<div class="paragraph">
<p>The sample application publishes some messages and then registers
a consumer to make some computations out of them. The
<a href="https://github.com/rabbitmq/rabbitmq-stream-dotnet-client/tree/main/docs/Documentation">source code is available on GitHub</a>.</p>
</div>
<div class="paragraph">
<p>The sample class starts with a few imports:</p>
</div>
<div class="listingblock">
<div class="title">Imports for the sample application</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">using System.Net;
using Microsoft.Extensions.Logging; // <b class="conum">(1)</b>
using RabbitMQ.Stream.Client; // <b class="conum">(2)</b>
using RabbitMQ.Stream.Client.Reliable; // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>Microsoft.Extensions.Logging</code> is used to log the events. ( not shipped with the client)</p>
</li>
<li>
<p><code>RabbitMQ.Stream.Client</code> is the main package to use the client</p>
</li>
<li>
<p><code>RabbitMQ.Stream.Client.Reliable</code> contains the <code>Producer</code> and <code>Consumer</code> implementations</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The next step is to create the <code>StreamSystem</code>. It is a management object
used to manage streams and create producers as well as consumers. The
next snippet shows how to create an <code>StreamSystem</code> instance and
create the stream used in the application:</p>
</div>
<div class="listingblock">
<div class="title">Creating the environment</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">var streamSystem = await StreamSystem.Create( // <b class="conum">(1)</b>
    new StreamSystemConfig() // <b class="conum">(2)</b>
    {
        UserName = &quot;guest&quot;,
        Password = &quot;guest&quot;,
        Endpoints = new List&lt;EndPoint&gt;() {new IPEndPoint(IPAddress.Loopback, 5552)}
    },
    streamLogger // <b class="conum">(3)</b>
).ConfigureAwait(false);

// Create a stream

const string StreamName = &quot;my-stream&quot;;
await streamSystem.CreateStream(
    new StreamSpec(StreamName) // <b class="conum">(4)</b>
    {
        MaxSegmentSizeBytes = 20_000_000 // <b class="conum">(5)</b>
    }).ConfigureAwait(false);</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Use <code>StreamSystem.Create(..)</code> to create the environment</p>
</li>
<li>
<p>Define the connection configuration</p>
</li>
<li>
<p>Add the logger. (Not mandatory it is very useful to understand what is going on)</p>
</li>
<li>
<p>Create the stream</p>
</li>
<li>
<p>Define the retention policy</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Then comes the publishing part. The next snippet shows how to create
a <code>Producer</code>, send messages, and handle publishing confirmations, to
make sure the broker has taken outbound messages into account.</p>
</div>
<div class="listingblock">
<div class="title">Publishing messages</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">var confirmationTaskCompletionSource = new TaskCompletionSource&lt;int&gt;();
var confirmationCount = 0;
const int MessageCount = 100;
var producer = await Producer.Create( // <b class="conum">(1)</b>
        new ProducerConfig(streamSystem, StreamName)
        {
            ConfirmationHandler = async confirmation =&gt; // <b class="conum">(2)</b>
            {
                Interlocked.Increment(ref confirmationCount);

                // here you can handle the confirmation
                switch (confirmation.Status)
                {
                    case ConfirmationStatus.Confirmed: // <b class="conum">(3)</b>
                        // all the messages received here are confirmed
                        if (confirmationCount == MessageCount)
                        {
                            Console.WriteLine(&quot;*********************************&quot;);
                            Console.WriteLine($&quot;All the {MessageCount} messages are confirmed&quot;);
                            Console.WriteLine(&quot;*********************************&quot;);
                        }

                        break;

                    case ConfirmationStatus.StreamNotAvailable:
                    case ConfirmationStatus.InternalError:
                    case ConfirmationStatus.AccessRefused:
                    case ConfirmationStatus.PreconditionFailed:
                    case ConfirmationStatus.PublisherDoesNotExist:
                    case ConfirmationStatus.UndefinedError:
                    case ConfirmationStatus.ClientTimeoutError:
                        // <b class="conum">(4)</b>
                        Console.WriteLine(
                            $&quot;Message {confirmation.PublishingId} failed with {confirmation.Status}&quot;);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }

                if (confirmationCount == MessageCount)
                {
                    confirmationTaskCompletionSource.SetResult(MessageCount);
                }

                await Task.CompletedTask.ConfigureAwait(false);
            }
        },
        producerLogger // <b class="conum">(5)</b>
    )
    .ConfigureAwait(false);


// Send 100 messages
Console.WriteLine(&quot;Starting publishing...&quot;);
for (var i = 0; i &lt; MessageCount; i++)
{
    await producer.Send( // <b class="conum">(6)</b>
        new Message(Encoding.ASCII.GetBytes($&quot;{i}&quot;))
    ).ConfigureAwait(false);
}


confirmationTaskCompletionSource.Task.Wait(); // <b class="conum">(7)</b>
await producer.Close().ConfigureAwait(false); // <b class="conum">(8)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create the <code>Producer</code> with <code>Producer.Create</code></p>
</li>
<li>
<p>Define the <code>ConfirmationHandler</code> where the messages are confirmed or not</p>
</li>
<li>
<p>Message is confirmed from the server</p>
</li>
<li>
<p>Message not confirmed</p>
</li>
<li>
<p>Add the logger. (Not mandatory it is very useful to understand what is going on)</p>
</li>
<li>
<p>Send messages with <code>producer.Send(Message)</code></p>
</li>
<li>
<p>Wait for messages confirmation</p>
</li>
<li>
<p>Close the producer</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>It is now time to consume the messages. The <code>Consumer.Create</code> lets us create a <code>Consumer</code>
and provide some logic on each incoming message by implementing a <code>MessageHandler</code>.
The next snippet does this to calculate a sum and output it once all the messages
have been received:</p>
</div>
<div class="listingblock">
<div class="title">Consuming messages</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">Console.WriteLine(&quot;Starting consuming...&quot;);
var consumer = await Consumer.Create( // <b class="conum">(1)</b>
        new ConsumerConfig(streamSystem, StreamName)
        {
            OffsetSpec = new OffsetTypeFirst(), // <b class="conum">(2)</b>
            MessageHandler = async (sourceStream, consumer, messageContext, message) =&gt; // <b class="conum">(3)</b>
            {
                if (Interlocked.Increment(ref consumerCount) == MessageCount)
                {
                    Console.WriteLine(&quot;*********************************&quot;);
                    Console.WriteLine($&quot;All the {MessageCount} messages are received&quot;);
                    Console.WriteLine(&quot;*********************************&quot;);
                    consumerTaskCompletionSource.SetResult(MessageCount);
                }
                await Task.CompletedTask.ConfigureAwait(false);
            }
        },
        consumerLogger // <b class="conum">(4)</b>
    )
    .ConfigureAwait(false);
consumerTaskCompletionSource.Task.Wait(); // <b class="conum">(5)</b>
await consumer.Close().ConfigureAwait(false); // <b class="conum">(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create the <code>Consumer</code> with <code>Consumer.Create</code></p>
</li>
<li>
<p>Start consuming from the beginning of the stream</p>
</li>
<li>
<p>Set up the logic to handle message</p>
</li>
<li>
<p>Add the logger. (Not mandatory it is very useful to understand what is going on)</p>
</li>
<li>
<p>Wait for all the messages are consumed</p>
</li>
<li>
<p>Close the consumer</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">Cleaning before terminating</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">await streamSystem.DeleteStream(StreamName).ConfigureAwait(false); // <b class="conum">(1)</b>
await streamSystem.Close().ConfigureAwait(false); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Delete the stream</p>
</li>
<li>
<p>Close the stream system</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">About logging</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">var factory = LoggerFactory.Create(builder =&gt;
{
    builder.AddSimpleConsole();
    builder.AddFilter(&quot;RabbitMQ.Stream&quot;, LogLevel.Information);
});

// Define the logger for the StreamSystem and the Producer/Consumer
var producerLogger = factory.CreateLogger&lt;Producer&gt;(); // <b class="conum">(1)</b>
var consumerLogger = factory.CreateLogger&lt;Consumer&gt;(); // <b class="conum">(2)</b>
var streamLogger = factory.CreateLogger&lt;StreamSystem&gt;(); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Define the logger for the producer</p>
</li>
<li>
<p>Define the logger for the consumer</p>
</li>
<li>
<p>Define the logger for the stream system</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The client is shipped with only with <code>Microsoft.Extensions.Logging.Abstractions</code> and you can use any logger you want.</p>
</div>
<div class="paragraph">
<p>The logger is not mandatory but it is highly recommended to configure it to understand what is happening.
In this example, we are using <code>Microsoft.Extensions.Logging.Console</code> to log to the console.
<code>Microsoft.Extensions.Logging.Console</code> is not shipped with the client.</p>
</div>
<div class="paragraph">
<div class="title">Run the sample application</div>
<p>You can run the sample application from the root of the project (you need
a running local RabbitMQ node with the stream plugin enabled):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$  dotnet run --gs
Starting publishing...
*********************************
All the 100 messages are confirmed
*********************************
Starting consuming...
*********************************
All the 100 messages are received
*********************************</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rabbitmq-stream-net-api">RabbitMQ Stream .NET API</h3>
<div class="sect3">
<h4 id="_overview">Overview</h4>
<div class="paragraph">
<p>This section describes the API to connect to the RabbitMQ Stream Plugin, publish messages, and consume messages.
There are 3 main interfaces:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RabbitMQ.Stream.Client</code> for connecting to a node and optionally managing streams.</p>
</li>
<li>
<p><code>RabbitMQ.Stream.Client.Reliable.Producer</code> to publish messages.</p>
</li>
<li>
<p><code>RabbitMQ.Stream.Client.Reliable.Consumer</code> to consume messages.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_streamsystem">StreamSystem</h4>
<div class="sect4">
<h5 id="_creating_the_streamsystem">Creating the StreamSystem</h5>
<div class="paragraph">
<p>The environment is the main entry point to a node or a cluster of nodes. <code>Producer</code> and
<code>Consumer</code> instances need an <code>StreamSystem</code> instance.
Here is the simplest way to create an <code>StreamSystem</code> instance:</p>
</div>
<div class="listingblock">
<div class="title">Creating an environment with all the defaults</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">private static async Task CreateSimple()
{
    var streamSystem = await StreamSystem.Create( // <b class="conum">(1)</b>
        new StreamSystemConfig()
    ).ConfigureAwait(false);


    await streamSystem.Close().ConfigureAwait(false); // <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create an environment that will connect to localhost:5552</p>
</li>
<li>
<p>Close the environment after usage</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note the streamSystem must be closed to release resources when it is no longer needed.</p>
</div>
<div class="paragraph">
<p>Consider the environment like a long-lived object.
An application will usually create one <code>StreamSystem</code> instance when it starts up and close it when it exits.</p>
</div>
<div class="paragraph">
<p>It is possible to use a multiple end-points to connect to a cluster of nodes.
The:</p>
</div>
<div class="listingblock">
<div class="title">Creating an streamSystem with multiple end-points</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">private static async Task CreateMultiEndPoints()
{
    var streamSystem = await StreamSystem.Create(
        new StreamSystemConfig()
        {
            UserName = &quot;guest&quot;,
            Password = &quot;guest&quot;,
            Endpoints = new List&lt;EndPoint&gt; // <b class="conum">(1)</b>
            {
                new IPEndPoint(IPAddress.Parse(&quot;192.168.5.12&quot;), 5552),
                new IPEndPoint(IPAddress.Parse(&quot;192.168.5.18&quot;), 5552),
            }
        }
    ).ConfigureAwait(false);
    await streamSystem.Close().ConfigureAwait(false); // <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Define the end-points to connect to</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By specifying several endpoints, the system will try to connect to the first one, and will pick a new endpoint randomly in case of disconnection.</p>
</div>
</div>
<div class="sect4">
<h5 id="understanding-connection-logic">Understanding Connection Logic</h5>
<div class="paragraph">
<p>Creating the StreamSystem to connect to a cluster node works usually seamlessly.
Creating publishers and consumers can cause problems as the client uses hints from the cluster to find the nodes where stream leaders and replicas are located to connect to the appropriate nodes.</p>
</div>
<div class="paragraph">
<p>These connection hints can be accurate or less appropriate depending on the infrastructure.
If you hit some connection problems at some point â€“ like hostnames impossible to resolve for client applications - this <a href="https://blog.rabbitmq.com/posts/2021/07/connecting-to-streams/">blog post</a> should help you understand what is going on and fix the issues.</p>
</div>
</div>
<div class="sect4">
<h5 id="_enabling_tls">Enabling TLS</h5>
<div class="paragraph">
<p>The default TLS port is 5551.</p>
</div>
<div class="listingblock">
<div class="title">Creating an StreamSystem that uses TLS</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">private static async Task CreateTls()
{
    var streamSystem = await StreamSystem.Create(
        new StreamSystemConfig()
        {
            UserName = &quot;guest&quot;,
            Password = &quot;guest&quot;,
            Ssl = new SslOption() // <b class="conum">(1)</b>
            {
                Enabled = true,
                ServerName = &quot;rabbitmq-stream&quot;,
                CertPath = &quot;/path/to/cert.pem&quot;, // <b class="conum">(2)</b>
                CertPassphrase = &quot;Password&quot;,
            }
        }
    ).ConfigureAwait(false);
    await streamSystem.Close().ConfigureAwait(false); // <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Enable TLS</p>
</li>
<li>
<p>Load certificates from PEM files</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">Creating an StreamSystem that uses TLS and external authentication</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">private static async Task CreateTlsExternal()
{
    var ssl = new SslOption() // <b class="conum">(1)</b>
    {
        Enabled = true,
        ServerName = &quot;server_name&quot;,
        CertPath = &quot;certs/client/keycert.p12&quot;,
        CertPassphrase = null, // in case there is no password
        CertificateValidationCallback = (sender, certificate, chain, errors) =&gt; true,
    };

    var config = new StreamSystemConfig()
    {
        UserName = &quot;user_does_not_exist&quot;,
        Password = &quot;password_does_not_exist&quot;,
        Ssl = ssl,
        Endpoints = new List&lt;EndPoint&gt;(new List&lt;EndPoint&gt;()
        {
            new DnsEndPoint(&quot;server_name&quot;, 5551)
        }),

        AuthMechanism = AuthMechanism.External, // <b class="conum">(2)</b>
    };
    
    var streamSystem = await StreamSystem.Create(config).ConfigureAwait(false);
    
    await streamSystem.Close().ConfigureAwait(false);
    
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Enable TLS and configure the certificates</p>
</li>
<li>
<p>Set the external authentication mechanism</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note: you need the <code>rabbitmq_auth_mechanism_ssl</code> plugin enabled on the server side to use external authentication.
<code>AuthMechanism.External</code> can be used from RabbitMQ server 3.11.19 and RabbitMQ 3.12.1 onwards.</p>
</div>
<div class="listingblock">
<div class="title">Creating a TLS environment that trusts all server certificates for development</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">private static async Task CreateTlsTrust()
{
    var streamSystem = await StreamSystem.Create(
        new StreamSystemConfig()
        {
            UserName = &quot;guest&quot;,
            Password = &quot;guest&quot;,
            Ssl = new SslOption() 
            {
                Enabled = true,
                AcceptablePolicyErrors = SslPolicyErrors.RemoteCertificateNotAvailable | // <b class="conum">(1)</b>
                                         SslPolicyErrors.RemoteCertificateChainErrors |
                                         SslPolicyErrors.RemoteCertificateNameMismatch
            }
        }
    ).ConfigureAwait(false);
    await streamSystem.Close().ConfigureAwait(false); 
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Trust all server certificates</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_the_stream_system">Configuring the Stream System</h5>
<div class="paragraph">
<p>The following table sums up the main settings to create an <code>StreamSystem</code> using the <code>StreamSystemConfig</code>:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parameter Name</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UserName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">User name to use to connect.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>guest</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Password</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Password to use to connect.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>guest</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VirtualHost</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Virtual host to connect to.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ClientProvidedName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">To identify the client in the management UI.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dotnet-stream-locator</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Heartbeat</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Time between heartbeats.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1 minute</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Endpoints</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The list of endpoints to connect to.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>localhost:5552</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>addressResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Contract to change resolved node address to connect to.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pass-through (no-op)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Ssl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configuration helper for TLS.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ConnectionPoolConfig</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Define the connection pool policies. See <a href="#connection-pool">Connection Pool</a> for more details.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 producer/consumer per connection</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="connection-pool">Connection pool</h5>
<div class="paragraph">
<p>Introduced on version 1.8.0.
With the connection pool you can define how many producers and consumers can be created on a single connection.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code> ConnectionPoolConfig = new ConnectionPoolConfig()
 {
    ProducersPerConnection = 2,
    ConsumersPerConnection = 3,
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default the connection pool is set to 1 producer and 1 consumer per connection.
The maximum number of producers and consumers per connection is 200.</p>
</div>
<div class="paragraph">
<p>An high value can reduce the number of connections to the server but it could reduce the performance of the producer and the consumer.</p>
</div>
<div class="paragraph">
<p>An low value can increase the number of connections to the server but it could increase the performance of the producer and the consumer.</p>
</div>
<div class="paragraph">
<p>The consumers share the same handler, so if you have a high number of consumers per connection, the handler could be a bottleneck. It means that if there is a slow consumer all the other consumers could be slow.</p>
</div>
<div class="paragraph">
<p>TIP:
You can use different StreamSystemConfig like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>streamSystemToReduceTheConnections = new StreamSystemConfig{
        ConnectionPoolConfig = new ConnectionPoolConfig() {
                ConsumersPerConnection = 50, // high value
                ProducersPerConnection = 50,  // high value
        }
}

streamSystemToIncreaseThePerformances = new StreamSystemConfig{
        ConnectionPoolConfig = new ConnectionPoolConfig() {
                ConsumersPerConnection = 1, // low value
                ProducersPerConnection = 1,  // low value
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is not a magic number, you have to test and evaluate the best value for your use case.</p>
</div>
</div>
<div class="sect4">
<h5 id="address-resolver">When a Load Balancer is in Use</h5>
<div class="paragraph">
<p>A load balancer can misguide the client when it tries to connect to nodes that host stream leaders and replicas.
The <a href="https://blog.rabbitmq.com/posts/2021/07/connecting-to-streams/">"Connecting to Streams"</a> blog post covers why client applications must connect to the appropriate nodes in a cluster and how a <a href="https://blog.rabbitmq.com/posts/2021/07/connecting-to-streams/#with-a-load-balancer">load balancer can make things complicated</a> for them.</p>
</div>
<div class="paragraph">
<p>The <code>StreamSystemConfig#AddressResolver(AddressResolver)</code> method allows intercepting the node resolution after metadata hints and before connection.
Applications can use this hook to ignore metadata hints and always use the load balancer, as illustrated in the following snippet:</p>
</div>
<div class="listingblock">
<div class="title">Using a custom address resolver to always use a load balancer</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">private static async Task CreateAddressResolver()
{
    var addressResolver = new AddressResolver(new IPEndPoint(IPAddress.Parse(&quot;xxx.xxx.xxx&quot;), 5552)); // <b class="conum">(1)</b>

    var streamSystem = await StreamSystem.Create(
        new StreamSystemConfig()
        {
            UserName = &quot;myuser&quot;,
            Password = &quot;mypassword&quot;,
            AddressResolver = addressResolver, // <b class="conum">(2)</b>
            Endpoints = new List&lt;EndPoint&gt; {addressResolver.EndPoint} // <b class="conum">(3)</b>
        }
    ).ConfigureAwait(false);


    await streamSystem.Close().ConfigureAwait(false);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the load balancer address</p>
</li>
<li>
<p>Use load balancer address for initial connection</p>
</li>
<li>
<p>Set the endpoints based on <code>AddressResolver</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The blog post covers the <a href="https://blog.rabbitmq.com/posts/2021/07/connecting-to-streams/#client-workaround-with-a-load-balancer">underlying details of this workaround</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_managing_streams">Managing Streams</h5>
<div class="paragraph">
<p>Streams are usually long-lived, centrally-managed entities, that is, applications are not supposed to create and delete them.
It is nevertheless possible to create and delete stream with the <code>StreamSystem</code>.
This comes in handy for development and testing purposes.</p>
</div>
<div class="paragraph">
<p>Streams are created with the <code>StreamSystem.CreateStream(..)</code> method:</p>
</div>
<div class="listingblock">
<div class="title">Creating a stream</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">private static async Task CreateStream()
{
    var streamSystem = await StreamSystem.Create(
        new StreamSystemConfig()
    ).ConfigureAwait(false);

    await streamSystem.CreateStream( // <b class="conum">(1)</b>
        new StreamSpec(&quot;my-stream&quot;)
    ).ConfigureAwait(false);
    await streamSystem.Close().ConfigureAwait(false); // <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create the <code>my-stream</code> stream</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>StreamSystem.Create</code> is idempotent: trying to re-create a stream with the same name and same properties (e.g. maximum size, see below) will not throw an exception.
In other words, you can be sure the stream has been created once <code>StreamSystem.Create</code> returns.
Note it is not possible to create a stream with the same name as an existing stream but with different properties.
Such a request will result in an exception.</p>
</div>
<div class="paragraph">
<p>Streams can be deleted with the <code>StreamSystem#Delete(String)</code> method:</p>
</div>
<div class="listingblock">
<div class="title">Deleting a stream</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">private static async Task DeleteStream()
{
    var streamSystem = await StreamSystem.Create(
        new StreamSystemConfig()
    ).ConfigureAwait(false);

    await streamSystem.DeleteStream(&quot;my-stream&quot;).ConfigureAwait(false); // <b class="conum">(1)</b>
    await streamSystem.Close().ConfigureAwait(false);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Delete the <code>my-stream</code> stream</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note you should avoid stream churn (creating and deleting streams repetitively) as their creation and deletion imply some significant housekeeping on the server side (interactions with the file system, communication between nodes of the cluster).</p>
</div>
<div id="limiting-the-size-of-a-stream" class="paragraph">
<p>It is also possible to limit the size of a stream when creating it.
A stream is an append-only data structure and reading from it does not remove data.
This means a stream can grow indefinitely.
RabbitMQ Stream supports a size-based and time-based retention policies: once the stream reaches a given size or a given age, it is truncated (starting from the beginning).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="title">Limit the size of streams if appropriate!</div>
<div class="paragraph">
<p>Make sure to set up a retention policy on potentially large streams if you don&#8217;t want to saturate the storage devices of your servers.
Keep in mind that this means some data will be erased!</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is possible to set up the retention policy when creating the stream:</p>
</div>
<div class="listingblock">
<div class="title">Setting the retention policy when creating a stream</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">private static async Task CreateStreamRetentionLen()
{
    var streamSystem = await StreamSystem.Create(
        new StreamSystemConfig()
    ).ConfigureAwait(false);

    await streamSystem.CreateStream( 
        new StreamSpec(&quot;my-stream&quot;)
        {
            MaxLengthBytes = 10_737_418_240, // <b class="conum">(1)</b>
            MaxSegmentSizeBytes = 524_288_000 // <b class="conum">(2)</b>
        }
    ).ConfigureAwait(false);
    await streamSystem.Close().ConfigureAwait(false); 
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the maximum size to 10 GB</p>
</li>
<li>
<p>Set the segment size to 500 MB</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The previous snippet mentions a segment size.
RabbitMQ Stream does not store a stream in a big, single file, it uses segment files for technical reasons.
A stream is truncated by deleting whole segment files (and not part of them)so the maximum size of a stream is usually significantly higher than the size of segment files. 500 MB is a reasonable segment file size to begin with.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">When does the broker enforce the retention policy?</div>
<div class="paragraph">
<p>The broker enforces the retention policy when the segments of a stream roll over, that is when the current segment has reached its maximum size and is closed in favor of a new one.
This means the maximum segment size is a critical setting in the retention mechanism.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>RabbitMQ Stream also supports a time-based retention policy: segments get truncated when they reach a certain age.
The following snippet illustrates how to set the time-based retention policy:</p>
</div>
<div class="listingblock">
<div class="title">Setting a time-based retention policy when creating a stream</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">private static async Task CreateStreamRetentionAge()
{
    var streamSystem = await StreamSystem.Create(
        new StreamSystemConfig()
    ).ConfigureAwait(false);

    await streamSystem.CreateStream( 
        new StreamSpec(&quot;my-stream&quot;)
        {
            MaxAge = TimeSpan.FromHours(6),  // <b class="conum">(1)</b>
            MaxSegmentSizeBytes = 524_288_000 // <b class="conum">(2)</b>
        }
    ).ConfigureAwait(false);
    await streamSystem.Close().ConfigureAwait(false); 
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the maximum age to 6 hours</p>
</li>
<li>
<p>Set the segment size to 500 MB</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="creating-a-producer">Producer</h4>
<div class="sect4">
<h5 id="_creating_a_producer">Creating a Producer</h5>
<div class="paragraph">
<p>A <code>Producer</code> instance is created with <code>Producer.Create</code>.
The only mandatory setting to specify is the stream to publish to:</p>
</div>
<div class="listingblock">
<div class="title">Creating a producer from the environment</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">var streamSystem = await StreamSystem.Create(
    new StreamSystemConfig()
).ConfigureAwait(false);

var producer = await Producer.Create( // <b class="conum">(1)</b>
    new ProducerConfig(
        streamSystem,
        &quot;my-stream&quot;) // <b class="conum">(2)</b>
).ConfigureAwait(false);

await producer.Close().ConfigureAwait(false); // <b class="conum">(3)</b>
await streamSystem.Close().ConfigureAwait(false);</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Use <code>Producer.Create</code> to define the producer</p>
</li>
<li>
<p>Specify the stream to publish to</p>
</li>
<li>
<p>Close the producer after usage</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Consider a <code>Producer</code> instance like a long-lived object, do not create one to send just one message.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Producer thread safety</div>
<div class="paragraph">
<p><code>Producer</code> instances are thread-safe when <code>Reference</code> is not set.
Starting from version 1.2.0 the <code>Reference</code> field is deprecated.
<code>Reference</code> is needed for deduplication see the Deduplication section for more details.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Internally, the <code>StreamSystem</code> will query the broker to find out about the topology of the stream and will create or re-use a connection to publish to the leader node of the stream.</p>
</div>
<div class="paragraph">
<p>The following table sums up the main settings to create a <code>ProducerConfig</code>:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parameter Name</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StreamSystem</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The StreamSystem to use to create the producer.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No default, mandatory setting.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>stream</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The stream to publish to.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No default, mandatory setting.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Reference</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The logical name of the producer. Specify a name to enable
<a href="#outbound-message-deduplication">message deduplication</a>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code> (no deduplication) - Deprecated in version 1.2.0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ConfirmationHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The confirmation handler where received the messages confirmations.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code> (no confirmation handler)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ClientProvidedName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The TCP connection name to identify the client.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dotnet-stream-producer</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MaxInFlight</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The maximum number of messages that can be in flight at any given time. Messages sent - Messages confirmed. To avoid to flood the broker with messages.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ReconnectStrategy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The strategy to use when the connection to the broker is lost.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BackOffReconnectStrategy</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MessagesBufferSize</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of the messages sent for each frame-send.
This value is valid only for the <code>Send(Message)</code> method.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TimeoutMessageAfter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Time to wait before considering a message as not confirmed.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3 seconds</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SuperStreamConfig</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The super stream configuration.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code> (no super stream)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StatusChanged</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The callback invoked when the producer status changes. See <a href="#entity-status">Producer Status</a> for more details.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_sending_messages">Sending Messages</h5>
<div class="paragraph">
<p>Once a <code>Producer</code> has been created, it is possible to send a message with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Producer#send(Message)</code>,</p>
</li>
<li>
<p><code>Producer#send(List&lt;Message&gt;)</code></p>
</li>
<li>
<p><code>Producer#send(List&lt;Message&gt; messages, CompressionType compressionType)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following snippet shows how to publish a message with a byte array payload:</p>
</div>
<div class="listingblock">
<div class="title">Sending a message</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">var streamSystem = await StreamSystem.Create(
    new StreamSystemConfig()
).ConfigureAwait(false);

var producer = await Producer.Create(
    new ProducerConfig(
        streamSystem,
        &quot;my-stream&quot;)
    {
        ConfirmationHandler = async confirmation =&gt; // <b class="conum">(5)</b>
        {
            switch (confirmation.Status)
            {
                case ConfirmationStatus.Confirmed:
                    Console.WriteLine(&quot;Message confirmed&quot;);
                    break;
                case ConfirmationStatus.ClientTimeoutError:
                case ConfirmationStatus.StreamNotAvailable:
                case ConfirmationStatus.InternalError:
                case ConfirmationStatus.AccessRefused:
                case ConfirmationStatus.PreconditionFailed:
                case ConfirmationStatus.PublisherDoesNotExist:
                case ConfirmationStatus.UndefinedError:
                    Console.WriteLine(&quot;Message not confirmed with error: {0}&quot;, confirmation.Status);
                    break;

                default:
                    throw new ArgumentOutOfRangeException();
            }


            await Task.CompletedTask.ConfigureAwait(false);
        }
    }
).ConfigureAwait(false);

var message = new Message(Encoding.UTF8.GetBytes(&quot;hello&quot;)); // <b class="conum">(1)</b>
await producer.Send(message).ConfigureAwait(false); // <b class="conum">(2)</b>
var list = new List&lt;Message&gt; {message};
await producer.Send(list).ConfigureAwait(false); // <b class="conum">(3)</b>
await producer.Send(list, CompressionType.Gzip).ConfigureAwait(false); // <b class="conum">(4)</b>

await producer.Close().ConfigureAwait(false);
await streamSystem.Close().ConfigureAwait(false);</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The payload of a message is an array of bytes.
Messages are not only made of a <code>byte[]</code> payload, we will see in
<a href="#working-with-complex-messages">the next section</a>
they can also carry pre-defined and application properties.</p>
</li>
<li>
<p>Send the message.
The method is asynchronous, internally the messages are buffered and sent in batch.
Most of the time you can use this method.</p>
</li>
<li>
<p>Batch send is synchronous, there is not additional buffering.
The messages are sent immediately.
This method is useful when you want to control the number of the messages to sent is a single frame.
Can be useful in case you need low latency.</p>
</li>
<li>
<p>Sub entry batching see <a href="#sub-entry-batching-and-compression">Sub Entry Batching</a> for more details.</p>
</li>
<li>
<p>The <code>ConfirmationHandler</code> defines an asynchronous callback invoked when the client received from the broker the confirmation the message has been taken into account.
The <code>ConfirmationHandler</code> is the place for any logic on publishing confirmation, including re-publishing the message if it is negatively acknowledged.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>MessagesConfirmation</code> contains the following information:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parameter Name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Stream</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The stream the message was published to.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PublishingId</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The publishing id of the message.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Status</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The confirmation status of the message. See <a href="#confirmation-status">Confirmation Status</a> for more details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Messages</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The list of messages that have been confirmed or not.</p></td>
</tr>
</tbody>
</table>
<div id="confirmation-status" class="paragraph">
<p><code>confirmation.Status</code> values:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parameter Name</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Source</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ConfirmationStatus.Confirmed</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The message has been confirmed by the broker.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Server</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ConfirmationStatus.Timeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Client gave up waiting for the message</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Client</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">StreamNotAvailable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The stream is not available.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Server</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">InternalError</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The broker encountered an internal error.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Server</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AccessRefused</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provided credentials are invalid or you lack permissions for specific vhost/etc.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Server</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PreconditionFailed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Catch-all for validation on server (eg. requested to create stream with different parameters but same name).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Server</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PublisherDoesNotExist</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The publisher does not exist.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Server</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UndefinedError</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Catch-all for any new status that is not yet handled in the library.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Server</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="title">Keep the confirmation callback as short as possible</div>
<div class="paragraph">
<p>The confirmation callback should be kept as short as possible to avoid blocking the connection thread.
Not doing so can make the <code>StreamSystem</code>, <code>Producer</code>, <code>Consumer</code> instances sluggish or even block them.
Any long processing should be done in a separate thread (e.g. with an asynchronous <code>Task.Run(&#8230;&#8203;.)</code>).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Mixing different send methods</div>
<div class="paragraph">
<p>You can mix different send methods.
For example you can send a message with <code>send(Message)</code> and then send a batch of messages with <code>send(List&lt;Message&gt;)</code>.
Avoid to sent the <code>Refence</code> property in the <code>ProducerConfig</code> it enables the deduplication and you could have unexpected results.</p>
</div>
<div class="paragraph">
<p><code>Reference</code> is deprecated in the version <code>1.2.0</code>  see deduplication section for more details.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="working-with-complex-messages">Working with Complex Messages</h5>
<div class="paragraph">
<p>The publishing example above showed that messages are made of a byte array payload, but it did not go much further.
Messages in RabbitMQ Stream can actually be more sophisticated, as they comply to the
<a href="https://www.amqp.org/resources/specifications">AMQP 1.0 message format</a>.</p>
</div>
<div class="paragraph">
<p>In a nutshell, a message in RabbitMQ Stream has the following structure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>properties: <em>a defined set of standard properties of the message</em> (e.g. message ID, correlation ID, content type, etc).</p>
</li>
<li>
<p>application properties: a set of arbitrary key/value pairs.</p>
</li>
<li>
<p>body: typically an array of bytes.</p>
</li>
<li>
<p>message annotations: a set of key/value pairs (aimed at the infrastructure).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The RabbitMQ Stream NET client uses the <code>Message</code> class to represent a message.</p>
</div>
<div class="listingblock">
<div class="title">Creating a message with properties</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">var streamSystem = await StreamSystem.Create(
    new StreamSystemConfig()
).ConfigureAwait(false);

var producer = await Producer.Create(
    new ProducerConfig(
        streamSystem,
        &quot;my-stream&quot;) { }
).ConfigureAwait(false);

var message = new Message(Encoding.UTF8.GetBytes(&quot;hello&quot;)) // <b class="conum">(1)</b>
{
    ApplicationProperties = new ApplicationProperties() // <b class="conum">(2)</b>
    {
        {&quot;key1&quot;, &quot;value1&quot;}, {&quot;key2&quot;, &quot;value2&quot;}
    },
    Properties = new Properties() // <b class="conum">(3)</b>
    {
        MessageId = &quot;message-id&quot;,
        CorrelationId = &quot;correlation-id&quot;,
        ContentType = &quot;application/json&quot;,
        ContentEncoding = &quot;utf-8&quot;,
    }
};

await producer.Send(message).ConfigureAwait(false);
await streamSystem.Close().ConfigureAwait(false);</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Get the message</p>
</li>
<li>
<p>Set the Application properties</p>
</li>
<li>
<p>Set the message Properties.
You usually don&#8217;t need to set the properties.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The <code>Message</code> contains also the following read-only properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MessageHeader</code></p>
</li>
<li>
<p><code>Annotations</code></p>
</li>
<li>
<p><code>AmqpValue</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These values are only for compatibility with the AMQP 1.0 message format.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Is RabbitMQ Stream based on AMQP 1.0?</div>
<div class="paragraph">
<p>AMQP 1.0 is a standard that defines <em>an efficient binary peer-to-peer protocol for transporting messages between two processes over a network</em>.
It also defines <em>an abstract message format, with concrete standard encoding</em>.
This is only the latter part that RabbitMQ Stream uses.
The AMQP 1.0 protocol is not used, only AMQP 1.0 encoded messages are wrapped into the RabbitMQ Stream binary protocol.</p>
</div>
<div class="paragraph">
<p>The actual AMQP 1.0 message encoding and decoding happen on the client side, the RabbitMQ Stream plugin stores only bytes, it has no idea that AMQP 1.0 message format is used.</p>
</div>
<div class="paragraph">
<p>AMQP 1.0 message format was chosen because of its flexibility and its advanced type system.
It provides good interoperability, which allows streams to be accessed as AMQP 0-9-1 queues, without data loss.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="outbound-message-deduplication">Message Deduplication</h5>
<div class="paragraph">
<p>RabbitMQ Stream provides publisher confirms to avoid losing messages: once the broker has persisted a message it sends a confirmation for this message.
But this can lead to duplicate messages: imagine the connection closes because of a network glitch after the message has been persisted but <em>before</em>
the confirmation reaches the producer.
Once reconnected, the producer will retry to send the same message, as it never received the confirmation.
So the message will be persisted twice.</p>
</div>
<div class="paragraph">
<p>Luckily RabbitMQ Stream can detect and filter out duplicated messages.</p>
</div>
<div class="paragraph">
<p>The client provides a specific class to handle deduplication: <code>DeduplicationProducer</code>.</p>
</div>
<div id="deduplication-multithreading" class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="title">Deduplication is not guaranteed when publishing on several threads</div>
<div class="paragraph">
<p>We&#8217;ll see below that deduplication works using a strictly increasing sequence for messages.
This means messages must be published in order and the preferred way to do this is usually <em>within a single thread</em>.
Even if messages are <em>created</em> in order, with the proper sequence ID, if they are published in several threads, they can get out of order, e.g. message 5 can be <em>published</em> before message 2.
The deduplication mechanism will then filter out message 2 in this case.</p>
</div>
<div class="paragraph">
<p>So you have to be very careful about the way your applications publish messages when deduplication is in use.
If you worry about performance, note it is possible to publish hundreds of thousands of messages in a single thread with RabbitMQ Stream.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_use_deduplicationproducer">Use DeduplicationProducer</h6>
<div class="paragraph">
<p>The <code>DeduplicationProducer</code> requires the <code>Reference</code> as mandatory parameter.
This parameter enables deduplication:</p>
</div>
<div class="listingblock">
<div class="title">Naming a producer to enable message deduplication</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">var streamSystem = await StreamSystem.Create(
    new StreamSystemConfig()
).ConfigureAwait(false);

var deduplicatingProducer = await DeduplicatingProducer.Create( // <b class="conum">(1)</b>
    new DeduplicatingProducerConfig(
        streamSystem,
        &quot;my-stream&quot;, &quot;my_producer_reference&quot;) { }
).ConfigureAwait(false);

var message = new Message(Encoding.UTF8.GetBytes(&quot;hello&quot;)); // <b class="conum">(2)</b>
await deduplicatingProducer.Send(1, message).ConfigureAwait(false); // <b class="conum">(3)</b>
await deduplicatingProducer.Send(2, message).ConfigureAwait(false);
await deduplicatingProducer.Send(3, message).ConfigureAwait(false);

// deduplication is enabled, so this message will be skipped
await deduplicatingProducer.Send(1, message).ConfigureAwait(false); // <b class="conum">(4)</b>


await streamSystem.Close().ConfigureAwait(false);</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Define the <code>DeduplicatingProducer</code> class with <code>Reference</code> property.</p>
</li>
<li>
<p>Get a message</p>
</li>
<li>
<p>Send three messages specifying the <code>publishingid</code> and the <code>Message</code>.</p>
</li>
<li>
<p>Send again the same message with the same <code>publishingid</code> and the <code>Message</code> will be skipped by the broker since the <code>publishingid</code> is already present with the <code>Reference</code> "my_producer_reference" .</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Thanks to the name, the broker will be able to track the messages it has persisted on a given stream for this producer.</p>
</div>
<div class="paragraph">
<p>Consider the <code>Reference</code> a logical name.
It should not be a random sequence that changes when the producer application is restarted.
Names like <code>online-shop-order</code> or
<code>online-shop-invoice</code> are better names than <code>3d235e79-047a-46a6-8c80-9d159d3e1b05</code>.
There should be only one living instance of a producer with a given name on a given stream at the same time.</p>
</div>
</div>
<div class="sect5">
<h6 id="_understanding_publishing_id">Understanding Publishing ID</h6>
<div class="paragraph">
<p>The <code>Reference</code> is only one part of the deduplication mechanism, the other part is the <em>message publishing ID</em>.
The publishing ID is a strictly increasing sequence, starting at 0 and incremented for each message.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the sequence should start at 0</p>
</li>
<li>
<p>the sequence must be strictly increasing</p>
</li>
<li>
<p>there can be gaps in the sequence (e.g. 0, 1, 2, 3, 6, 7, 9, 10, etc)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A custom publishing ID sequence has usually a meaning: it can be the line number of a file or the primary key in a database.</p>
</div>
<div class="paragraph">
<p>Note the publishing ID is not part of the message: it is not stored with the message and so is not available when consuming the message.
It is still possible to store the value in the AMQP 1.0 message application properties or in an appropriate properties (e.g. <code>messageId</code>).</p>
</div>
</div>
<div class="sect5">
<h6 id="_restarting_a_producer_where_it_left_off">Restarting a Producer Where It Left Off</h6>
<div class="paragraph">
<p>Using a custom publishing sequence is even more useful to restart a producer where it left off.
Imagine a scenario whereby the producer is sending a message for each line in a file and the application uses the line number as the publishing ID.
If the application restarts because of some necessary maintenance or even a crash, the producer can restart from the beginning of the file: there would no duplicate messages because the producer has a name and the application sets publishing IDs appropriately.
Nevertheless, this is far from ideal, it would be much better to restart just after the last line the broker successfully confirmed.
Fortunately this is possible thanks to the <code>DeduplicatingProducer#GetLastPublishedId()</code> method, which returns the last publishing ID for a given producer.
As the publishing ID in this case is the line number, the application can easily scroll to the next line and restart publishing from there.</p>
</div>
<div class="paragraph">
<p>The next snippet illustrates the use of <code>DeduplicatingProducer#GetLastPublishedId()</code>:</p>
</div>
<div class="listingblock">
<div class="title">Setting a producer where it left off</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">var streamSystem = await StreamSystem.Create(
    new StreamSystemConfig()
).ConfigureAwait(false);

var deduplicatingProducer = await DeduplicatingProducer.Create( // <b class="conum">(1)</b>
    new DeduplicatingProducerConfig(
        streamSystem,
        &quot;my-stream&quot;, &quot;my_producer_reference&quot;) { }
).ConfigureAwait(false);

var lastid = await deduplicatingProducer.GetLastPublishedId().ConfigureAwait(false); // <b class="conum">(2)</b>
var message = new Message(Encoding.UTF8.GetBytes(&quot;hello&quot;));

await deduplicatingProducer.Send(lastid + 1, message).ConfigureAwait(false); // <b class="conum">(3)</b>
await deduplicatingProducer.Send(lastid + 2, message).ConfigureAwait(false);
await deduplicatingProducer.Send(lastid + 3, message).ConfigureAwait(false);
await streamSystem.Close().ConfigureAwait(false);</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Get a <code>DeduplicatingProducer</code> instance</p>
</li>
<li>
<p>Query last publishing ID for this producer</p>
</li>
<li>
<p>Use the lastid and increment it</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sub-entry-batching-and-compression">Sub-Entry Batching and Compression</h5>
<div class="paragraph">
<p>RabbitMQ Stream provides a special mode to publish, store, and dispatch messages: sub-entry batching.
This mode increases throughput at the cost of increased latency and potential duplicated messages even when deduplication is enabled.
It also allows using compression to reduce bandwidth and storage if messages are reasonably similar, at the cost of increasing CPU usage on the client side.</p>
</div>
<div class="paragraph">
<p>Sub-entry batching consists in squeezing several messages â€“ a batch â€“ in the slot that is usually used for one message.
This means outbound messages are not only batched in publishing frames, but in sub-entries as well.</p>
</div>
<div class="paragraph">
<p>The following snippet shows how to enable sub-entry batching:</p>
</div>
<div class="listingblock">
<div class="title">Enabling sub-entry batching</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">var streamSystem = await StreamSystem.Create(
    new StreamSystemConfig()
).ConfigureAwait(false);

var producer = await Producer.Create( // <b class="conum">(1)</b>
    new ProducerConfig(
        streamSystem,
        &quot;my-stream&quot;) // <b class="conum">(2)</b>
).ConfigureAwait(false);

var message = new Message(Encoding.UTF8.GetBytes(&quot;hello&quot;)); 
var list = new List&lt;Message&gt; {message, message, message}; // <b class="conum">(1)</b>
await producer.Send(list, CompressionType.Gzip).ConfigureAwait(false); // <b class="conum">(2)</b>

await producer.Close().ConfigureAwait(false);
await streamSystem.Close().ConfigureAwait(false);</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Define a list of messages to compress</p>
</li>
<li>
<p>Send the list of messages to the broker in tis case 3 messages compressed with GZIP</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Reasonable values for the sub-entry size usually go from 10 to a few dozens.</p>
</div>
<div class="paragraph">
<p>A sub-entry batch will go directly to disc after it reached the broker, so the publishing client has complete control over it.
This is the occasion to take advantage of the similarity of messages and compress them.</p>
</div>
<div class="paragraph">
<p>The following table lists the supported algorithms, general information about them, and the respective implementations used by default.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Algorithm</th>
<th class="tableblock halign-left valign-top">Overview</th>
<th class="tableblock halign-left valign-top">Implementation used</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CompressionType.None</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No compression.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.wikipedia.org/wiki/Gzip">CompressionType.Gzip</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Has a high compression ratio but is slow compared to other algorithms.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">.Net Implementation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.wikipedia.org/wiki/Snappy_(compression)">Snappy</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aims for reasonable compression ratio and very high speeds.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Not shipped with the client library, but can be added with the <code>ICompressionCodec</code> interface.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.wikipedia.org/wiki/LZ4_(compression_algorithm)">LZ4</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aims for good trade-off between speed and compression ratio.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Not shipped with the client library, but can be added with the <code>ICompressionCodec</code> interface.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.wikipedia.org/wiki/Zstd">zstd</a> (Zstandard)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aims for high compression ratio and high speed, especially for decompression.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Not shipped with the client library, but can be added with the <code>ICompressionCodec</code> interface.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>You are encouraged to test and evaluate the compression algorithms depending on your needs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Consumers, sub-entry batching, and compression</div>
<div class="paragraph">
<p>There is no configuration required for consumers with regard to sub-entry batching and compression.
The broker dispatches messages to client libraries: they are supposed to figure out the format of messages, extract them from their sub-entry, and decompress them if necessary.
So when you set up sub-entry batching and compression in your publishers, the consuming applications must use client libraries that support this mode, which is the case for the stream Net client.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can add a compression algorithm to the client library by implementing the <code>ICompressionCodec</code> interface and registering it with the <code>StreamCompressionCodecs</code> class.</p>
</div>
<div class="paragraph">
<p>The following snippet shows how to add a compression algorithm to the client library:</p>
</div>
<div class="listingblock">
<div class="title">Adding a compression algorithm</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">class StreamLz4Codec : ICompressionCodec // <b class="conum">(1)</b>
{



    private ReadOnlySequence&lt;byte&gt; _compressedReadOnlySequence;
    public void Compress(List&lt;Message&gt; messages)
    {
        MessagesCount = messages.Count;
        UnCompressedSize = messages.Sum(msg =&gt; 4 + msg.Size);
        var messagesSource = new Span&lt;byte&gt;(new byte[UnCompressedSize]);
        var offset = 0;
        foreach (var msg in messages)
        {
            offset += WriteUInt32(messagesSource.Slice(offset), (uint)msg.Size);
            offset += msg.Write(messagesSource.Slice(offset));
        }

        using var source = new MemoryStream(messagesSource.ToArray());
        using var destination = new MemoryStream();
        var settings = new LZ4EncoderSettings {ChainBlocks = false};
        using (var target = LZ4Stream.Encode(destination, settings, false))
        {
            source.CopyTo(target);
        }

        _compressedReadOnlySequence = new ReadOnlySequence&lt;byte&gt;(destination.ToArray());
    }

    public ReadOnlySequence&lt;byte&gt; UnCompress(ReadOnlySequence&lt;byte&gt; source, uint dataLen, uint unCompressedDataSize)
    {
        using var target = new MemoryStream();
        using (var sourceDecode = LZ4Stream.Decode(new MemoryStream(source.ToArray())))
        {
            sourceDecode.CopyTo(target);
        }
        return new ReadOnlySequence&lt;byte&gt;(target.ToArray());
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Implement the <code>ICompressionCodec</code> interface with all the required methods</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following snippet shows how to register the compression algorithm with the <code>StreamCompressionCodecs</code> class:</p>
</div>
<div class="listingblock">
<div class="title">Registering a compression algorithm</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">StreamCompressionCodecs.RegisterCodec&lt;StreamLz4Codec&gt;(CompressionType.Lz4); // <b class="conum">(1)</b>

var producer = await Producer.Create(
    new ProducerConfig(
        streamSystem,
        &quot;my-stream&quot;) { }
).ConfigureAwait(false);

var message = new Message(Encoding.UTF8.GetBytes(&quot;hello&quot;));
var list = new List&lt;Message&gt; {message, message, message}; 
await producer.Send(list, CompressionType.Lz4).ConfigureAwait(false); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Register the compression algorithm with the <code>StreamCompressionCodecs</code> class</p>
</li>
<li>
<p>Use the compression algorithm in the <code>producer.Send(list, CompressionType.Lz4)</code></p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="creating-a-consumer">Consumer</h4>
<div class="paragraph">
<p><code>Consumer</code> is the API to consume messages from a stream.</p>
</div>
<div class="sect4">
<h5 id="_creating_a_consumer">Creating a Consumer</h5>
<div class="paragraph">
<p>A <code>Consumer</code> instance is created with <code>Consumer.Create(..)</code>.
The main settings are the stream to consume from, the place in the stream to start consuming from (the <em>offset</em>), and a callback when a message is received (the <code>MessageHandler</code>).
The next snippet shows how to create a <code>Consumer</code>:</p>
</div>
<div class="listingblock">
<div class="title">Creating a consumer</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">var streamSystem = await StreamSystem.Create(
    new StreamSystemConfig()
).ConfigureAwait(false);

var consumer = await Consumer.Create( // <b class="conum">(1)</b>
    new ConsumerConfig( // <b class="conum">(2)</b>
        streamSystem,
        &quot;my-stream&quot;)
    {
        OffsetSpec = new OffsetTypeTimestamp(), // <b class="conum">(3)</b>
        MessageHandler = async (stream, consumer, context, message) =&gt; // <b class="conum">(4)</b>
        {
            Console.WriteLine($&quot;Received message: {Encoding.UTF8.GetString(message.Data.Contents)}&quot;);
            await Task.CompletedTask.ConfigureAwait(false);
        }
    }
).ConfigureAwait(false);

await consumer.Close().ConfigureAwait(false); // <b class="conum">(5)</b>
await streamSystem.Close().ConfigureAwait(false);</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Use <code>Consumer.Create()</code> to define the consumer</p>
</li>
<li>
<p>Specify <code>ConsumerConfig</code> to configure the consumer behavior with the <code>streamSystem</code> and <code>streamName</code> to consume from</p>
</li>
<li>
<p>Specify where to start consuming from</p>
</li>
<li>
<p>Handle the messages</p>
</li>
<li>
<p>Close consumer after usage</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The broker start sending messages as soon as the <code>Consumer</code> instance is created.</p>
</div>
<div class="paragraph">
<p>Staring from the 1.3.0 version, the <code>Consumer#MessageHandler</code> API runs in a separated <code>Task</code> and it is possible to use <code>async</code>/<code>await</code> in the handler.</p>
</div>
<div class="paragraph">
<p>The following table sums up the main settings to create a <code>Consumer</code> with <code>ConsumerConfig</code>:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parameter Name</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StreamSystem</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The StreamSystem to use.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No default, mandatory setting.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Stream</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The stream to consume from.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No default, mandatory setting.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OffsetSpec</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The offset to start consuming from.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OffsetTypeNext()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MessageHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The callback for inbound messages.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No default.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Reference</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The consumer name (for <a href="#consumer-offset-tracking">offset tracking</a>.)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code> (no offset tracking)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ReconnectStrategy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The strategy to use when the connection to the broker is lost.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BackOffReconnectStrategy</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ClientProvidedName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">To identify the client in the management UI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dotnet-stream-conusmer</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IsSingleActiveConsumer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enable the Single Active Consumer feature</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IsSuperStream</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enable the Super Stream feature</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ICrc32</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The <a href="#crc-on-delivery">CRC32 implementation</a> to use to validate the chunk server crc32 .</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code> (no CRC32)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StatusChanged</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The callback invoked when the consumer status changes. See <a href="#entity-status">Consumer Status</a> for more details.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Why is my consumer not consuming?</div>
<div class="paragraph">
<p>A consumer starts consuming at the very end of a stream by default (<code>next</code> offset).
This means the consumer will receive messages as soon as a producer publishes to the stream.
<em>This also means that if no producers are currently publishing to the stream, the consumer will stay idle, waiting for new messages to come in</em>.
See the <a href="#specifying-an-offset">offset section</a> to find out more about the different types of offset specification.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="crc-on-delivery">Check the CRC on Delivery</h5>
<div class="paragraph">
<p>RabbitMQ Stream provides a CRC32 checksum on each chunk.
The client library can check the checksum before parse the chunk and throw an <code>CrcException</code> exception if the validation fails.
By default the CRC32 checksum is not enabled, to enable it you need to set the <code>ICrc32</code> interface in the <code>ConsumerConfig</code>:</p>
</div>
<div class="listingblock">
<div class="title">Checking the CRC32 checksum on the chunk</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">private class UserCrc32 : ICrc32 // <b class="conum">(1)</b>
{
    public byte[] Hash(byte[] data)
    {
        // Here we use the System.IO.Hashing.Crc32 implementation
        return System.IO.Hashing.Crc32.Hash(data);
    }
}

public static async Task CreateConsumerWithCrc()
{
    var streamSystem = await StreamSystem.Create(
        new StreamSystemConfig()
    ).ConfigureAwait(false);
    var consumer = await Consumer.Create(
        new ConsumerConfig(
            streamSystem,
            &quot;my-stream&quot;)
        {
            Crc32 = new UserCrc32(), // <b class="conum">(2)</b>
            OffsetSpec = new OffsetTypeTimestamp(),</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>An implementation of the <code>ICrc32</code> interface.
You are free to use any implementation you want.
The client is tested with <code>System.IO.Hashing</code>.
<code>System.IO.Hashing</code> is not shipped with the client library.</p>
</li>
<li>
<p>Set the <code>ICrc32</code> implementation in the <code>ConsumerConfig</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>It is recommended to use it.
It <em>could</em> reduce the performance of the consumer.
It depends on the use case.</p>
</div>
</div>
<div class="sect4">
<h5 id="specifying-an-offset">Specifying an Offset</h5>
<div class="paragraph">
<p>The offset is the place in the stream where the consumer starts consuming from.
The possible values for the offset parameter are the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>OffsetTypeFirst()</code>: starting from the first available offset.
If the stream has not been <a href="#limiting-the-size-of-a-stream">truncated</a>, this means the beginning of the stream (offset 0).</p>
</li>
<li>
<p><code>OffsetTypeLast()</code>: starting from the end of the stream and returning the last <a href="#chunk-definition">chunk</a> of messages immediately (if the stream is not empty).</p>
</li>
<li>
<p><code>OffsetTypeNext()</code>: starting from the next offset to be written.
Contrary to <code>OffsetTypeLat()</code>, consuming with <code>OffsetTypeNext()</code>
will not return anything if no-one is publishing to the stream.
The broker will start sending messages to the consumer when messages are published to the stream.</p>
</li>
<li>
<p><code>OffsetTypeOffset(offset)</code>: starting from the specified offset. 0 means consuming from the beginning of the stream (first messages).
The client can also specify any number, for example the offset where it left off in a previous incarnation of the application.</p>
</li>
<li>
<p><code>OffsetTypeTimestamp(timestamp)</code>: starting from the messages stored after the specified timestamp.
Note consumers can receive messages published a bit before the specified timestamp.
Application code can filter out those messages if necessary.</p>
</li>
</ul>
</div>
<div id="chunk-definition" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">What is a chunk of messages?</div>
<div class="paragraph">
<p>A chunk is simply a batch of messages.
This is the storage and transportation unit used in RabbitMQ Stream, that is messages are stored contiguously in a chunk and they are delivered as part of a chunk.
A chunk can be made of one to several thousands of messages, depending on the ingress.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following figure shows the different offset specifications in a stream made of 2 chunks:</p>
</div>
<div class="literalblock">
<div class="title">Offset specifications in a stream made of 2 chunks</div>
<div class="content">
<pre>   +------------------------------------------+ +-------------------------+
   |  +-----+ +-----+ +-----+ +-----+ +-----+ | | +-----+ +-----+ +-----+ |
   |  |  0  | |  1  | |  2  | |  3  | |  4  | | | |  5  | |  6  | |  7  | |
   |  +-----+ +-----+ +-----+ +-----+ +-----+ | | +-----+ +-----+ +-----+ |
   +------------------------------------------+ +-------------------------+
         ^            Chunk 1    ^                   ^    Chunk 2            ^
         |                       |                   |                       |
       FIRST                  OFFSET 3              LAST                    NEXT</pre>
</div>
</div>
<div class="paragraph">
<p>Each chunk contains a timestamp of its creation time.
This is this timestamp the broker uses to find the appropriate chunk to start from when using a timestamp specification.
The broker chooses the closest chunk <em>before</em> the specified timestamp, that is why consumers may see messages published a bit before what they specified.</p>
</div>
</div>
<div class="sect4">
<h5 id="consumer-offset-tracking">Tracking the Offset for a Consumer</h5>
<div class="paragraph">
<p>RabbitMQ Stream provides server-side offset tracking.
This means a consumer can track the offset it has reached in a stream.
It allows a new incarnation of the consumer to restart consuming where it left off.
All of this without an extra datastore, as the broker stores the offset tracking information.</p>
</div>
<div class="paragraph">
<p>Offset tracking works in 2 steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the consumer must have a <strong>reference</strong>.
The name is set with <code>ConsumerConfig#Reference</code>.
The name can be any value (under 256 characters) and is expected to be unique (from the application point of view).
Note neither the client library, nor the broker enforces uniqueness of the name: if 2 <code>Consumer</code> .NET instances share the same name, their offset tracking will likely be interleaved, which applications usually do not expect.</p>
</li>
<li>
<p>the consumer must periodically <strong>store the offset</strong> it has reached so far.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Whatever tracking strategy you use, <strong>a consumer must have a <code>Reference</code> to be able to store offsets</strong>.</p>
</div>
<div class="sect5">
<h6 id="consumer-manual-offset-tracking">Manual Offset Tracking</h6>
<div class="paragraph">
<p>The manual tracking strategy lets the developer in charge of storing offsets whenever they want, not only after a given number of messages has been received and supposedly processed, like automatic tracking does.</p>
</div>
<div class="paragraph">
<p>The following snippet shows how to enable manual tracking and how to store the offset at some point:</p>
</div>
<div class="listingblock">
<div class="title">Using manual tracking with defaults</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">var streamSystem = await StreamSystem.Create(
    new StreamSystemConfig()
).ConfigureAwait(false);

var consumed = 0;
var consumer = await Consumer.Create(
    new ConsumerConfig(
        streamSystem,
        &quot;my-stream&quot;)
    {
        Reference = &quot;my-reference&quot;, // <b class="conum">(1)</b>
        MessageHandler = async (stream, consumer, context, message) =&gt;
        {
            if (consumed++ % 10000 == 0)
            {
                await consumer.StoreOffset(context.Offset).ConfigureAwait(false); // <b class="conum">(2)</b>
            }

            Console.WriteLine($&quot;Received message: {Encoding.UTF8.GetString(message.Data.Contents)}&quot;);
            await Task.CompletedTask.ConfigureAwait(false);
        }
    }
).ConfigureAwait(false);

await consumer.Close().ConfigureAwait(false);
await streamSystem.Close().ConfigureAwait(false);</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the consumer Reference (mandatory for offset tracking)</p>
</li>
<li>
<p>Store the current offset on some condition</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The snippet above uses <code>consumer.StoreOffset(context.Offset)</code> to store at the offset of the current message.</p>
</div>
</div>
<div class="sect5">
<h6 id="_considerations_on_offset_tracking">Considerations On Offset Tracking</h6>
<div class="paragraph">
<p><em>When to store offsets?</em> Avoid storing offsets too often or, worse, for each message.
Even though offset tracking is a small and fast operation, it will make the stream grow unnecessarily, as the broker persists offset tracking entries in the stream itself.</p>
</div>
<div class="paragraph">
<p>A good rule of thumb is to store the offset every few thousands of messages.
Of course, when the consumer will restart consuming in a new incarnation, the last tracked offset may be a little behind the very last message the previous incarnation actually processed, so the consumer may see some messages that have been already processed.</p>
</div>
<div class="paragraph">
<p>A solution to this problem is to make sure processing is idempotent or filter out the last duplicated messages.</p>
</div>
<hr>
<div class="paragraph">
<p><em>Is the offset a reliable absolute value?</em> Message offsets may not be contiguous.
This implies that the message at offset 500 in a stream may not be the 501 message in the stream (offsets start at 0).
There can be different types of entries in a stream storage, a message is just one of them.
For example, storing an offset creates an offset tracking entry, which has its own offset.</p>
</div>
<div class="paragraph">
<p>This means one must be careful when basing some decision on offset values, like a modulo to perform an operation every X messages.
As the message offsets have no guarantee to be contiguous, the operation may not happen exactly every X messages.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="single-active-consumer">Single Active Consumer</h5>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Single Active Consumer requires <strong>RabbitMQ 3.11</strong> or more.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When the single active consumer feature is enabled for several consumer instances sharing the same stream and name, only one of these instances will be active at a time and so will receive messages.
The other instances will be idle.</p>
</div>
<div class="paragraph">
<p>The single active consumer feature provides 2 benefits:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Messages are processed in order: there is only one consumer at a time.</p>
</li>
<li>
<p>Consumption continuity is maintained: a consumer from the group will take over if the active one stops or crashes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A typical sequence of events would be the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Several instances of the same consuming application start up.</p>
</li>
<li>
<p>Each application instance registers a single active consumer.
The consumer instances share the same name.</p>
</li>
<li>
<p>The broker makes the first registered consumer the active one.</p>
</li>
<li>
<p>The active consumer receives and processes messages, the other consumer instances remain idle.</p>
</li>
<li>
<p>The active consumer stops or crashes.</p>
</li>
<li>
<p>The broker chooses the consumer next in line to become the new active one.</p>
</li>
<li>
<p>The new active consumer starts receiving messages.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The next figures illustrates this mechanism.
There can be only one active consumer:</p>
</div>
<div class="literalblock">
<div class="title">The first registered consumer is active, the next ones are inactive</div>
<div class="content">
<pre>                    +----------+
             +------+ consumer + Active
             |      +----------+
             |
+--------+   |      +=---------+
+ stream +---+------+ consumer + Inactive
+--------+   |      +----------+
             |
             |      +=---------+
             +------+ consumer + Inactive
                    +----------+</pre>
</div>
</div>
<div class="paragraph">
<p>The broker rolls over to another consumer when the active one stops or crashes:</p>
</div>
<div class="literalblock">
<div class="title">When the active consumer stops, the next in line becomes active</div>
<div class="content">
<pre>                    +=---------+
                    | consumer + Closed
                    +----------+

+--------+          +----------+
+ stream +---+------+ consumer + Active
+--------+   |      +----------+
             |
             |      +=---------+
             +------+ consumer + Inactive
                    +----------+</pre>
</div>
</div>
<div class="paragraph">
<p>Note there can be several groups of single active consumers on the same stream.
What makes them different from each other is the name used by the consumers.
The broker deals with them independently.
Let&#8217;s use an example.
Imagine 2 different <code>app-1</code> and <code>app-2</code> applications consuming from the same stream, with 3 identical instances each.
Each instance registers 1 single active consumer with the name of the application.
We end up with 3 <code>app-1</code> consumers and 3 <code>app-2</code> consumers, 1 active consumer in each group, so overall 6 consumers and 2 active ones, all of this on the same stream.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see now the API for single active consumer.</p>
</div>
<div class="sect5">
<h6 id="_enabling_single_active_consumer">Enabling Single Active Consumer</h6>
<div class="paragraph">
<p>Use the <code>ConsumerBuilder#singleActiveConsumer()</code> method to enable the feature:</p>
</div>
<div class="listingblock">
<div class="title">Enabling single active consumer</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">var streamSystem = await StreamSystem.Create(
    new StreamSystemConfig()
).ConfigureAwait(false);

var consumer = await Consumer.Create(
    new ConsumerConfig(
        streamSystem,
        &quot;my-stream&quot;)
    {
        Reference = &quot;my-reference&quot;, // <b class="conum">(1)</b>
        IsSingleActiveConsumer = true, // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the <code>Reference</code> name (mandatory to enable single active consumer)</p>
</li>
<li>
<p>Enable single active consumer</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>With the configuration above, the consumer will take part in the <code>application-1</code> group on the <code>my-stream</code> stream.
If the consumer instance is the first in a group, it will get messages as soon as there are some available.
If it is not the first in the group, it will remain idle until it is its turn to be active (likely when all the instances registered before it are gone).</p>
</div>
</div>
<div class="sect5">
<h6 id="_offset_tracking">Offset Tracking</h6>
<div class="paragraph">
<p>Single active consumer and offset tracking work together: when the active consumer goes away, another consumer takes over and you need to tell the client library where to resume from and you can do this by implementing the <code>ConsumerUpdateListener</code> API.</p>
</div>
</div>
<div class="sect5">
<h6 id="consumer-update-listener">Reacting to Consumer State Change</h6>
<div class="paragraph">
<p>The broker notifies a consumer that becomes active before dispatching messages to it.
The broker expects a response from the consumer and this response contains the offset the dispatching should start from.
So this is the consumer&#8217;s responsibility to compute the appropriate offset, not the broker&#8217;s.
The default behavior is to look up the last stored offset for the consumer on the stream.
This works when server-side offset tracking is in use, but it does not when the application chose to use an external store for offset tracking.
In this case, it is possible to use the <code>ConsumerConfig#ConsumerUpdateListener()</code> method like demonstrated in the following snippet:</p>
</div>
<div class="listingblock">
<div class="title">Fetching the last stored offset from an external store in the consumer update listener callback</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">var streamSystem = await StreamSystem.Create(
    new StreamSystemConfig()
).ConfigureAwait(false);

var consumer = await Consumer.Create(
    new ConsumerConfig(
        streamSystem,
        &quot;my-stream&quot;)
    {
        Reference = &quot;my-reference&quot;, // <b class="conum">(1)</b>
        IsSingleActiveConsumer = true, // <b class="conum">(2)</b>
        ConsumerUpdateListener = async (consumerRef, stream, isActive) =&gt; // <b class="conum">(3)</b>
        {
            var offset = await streamSystem.QueryOffset(consumerRef, stream).ConfigureAwait(false);
            return new OffsetTypeOffset(offset);
        },</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the <code>Reference</code> name (mandatory to enable single active consumer)</p>
</li>
<li>
<p>Enable single active consumer</p>
</li>
<li>
<p>Handle <code>ConsumerUpdateListener</code> callback</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="entity-status">Producer/Consumer change status callback</h4>
<div class="paragraph">
<p><code>Producer</code> and <code>Consumer</code> classes provide a callback to handle the status change.
It is possible to configure the event using the configuration <code>StatusChanged</code> property.</p>
</div>
<div class="paragraph">
<p>like the following snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">var conf = new ConsumerConfig(system, stream)
{
    StatusChanged = (statusInfo) =&gt;
    {
        Console.WriteLine($&quot;Consumer status changed to {statusInfo}&quot;);
    }
};
var consumer = Consumer.Create(conf);</code></pre>
</div>
</div>
<div class="paragraph">
<p>the <code>statusInfo</code> contains the following information:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parameter Name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>From</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The previous status</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>To</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The new status</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Stream</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The stream where the Producer or the Consumer is connected</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Identifier</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The identifier of the Producer or the Consumer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Partition</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The partition in case of super stream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Reason</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The reason of the status change. See <a href="#status-reason">Status Reason</a> for more details.</p></td>
</tr>
</tbody>
</table>
<div id="status-reason" class="paragraph">
<p><code>statusInfo.Reason</code> values:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parameter Name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>None</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No reason, default value</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UnexpectedlyDisconnected</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The client was unexpectedly disconnected from the server</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MetaDataUpdate</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The server has updated the metadata of the stream. See this <a href="https://docs.google.com/presentation/d/111PccBLRGb-RNpYEKeIm2MQvdky-fXrQ/edit?usp=sharing&amp;ouid=106772747306273309885">presentation</a> about metadata update for more details</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ClosedByUser</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The client was closed by the user</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ClosedByStrategyPolicy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The Producer or Consumer was closed by the strategy policy</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BoolFailure</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The Producer or Consumer has failed to connect to the server.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>A full example of the status change callback can be found in <a href="https://github.com/rabbitmq/rabbitmq-stream-dotnet-client/tree/main/docs/ReliableClient">here</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="low-high-level-classes">Low Level and High Level classes</h4>
<div class="ulist">
<div class="title">NET stream client provides two types of classes:</div>
<ul>
<li>
<p>Low-level classes</p>
</li>
<li>
<p>High-level classes</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_low_level_classes">Low-level classes</h5>
<div class="ulist">
<ul>
<li>
<p><code>RabbitMQ.Stream.Client.RawProducer</code> - Low-level producer class</p>
</li>
<li>
<p><code>RabbitMQ.Stream.Client.RawConsumer</code>  - Low-level consumer class</p>
</li>
<li>
<p><code>RabbitMQ.Stream.Client.RawSuperStreamProducer</code> - Low-level super-stream producer class</p>
</li>
<li>
<p><code>RabbitMQ.Stream.Client.RawSuperStreamConsumer</code> - Low-level super-stream consumer class</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Classes are used to interact with the stream server in a low level way.
They are used to create streams, publish messages, consume messages, etc.
They give you all the callbacks to manually handle events like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Disconnection</code></p>
</li>
<li>
<p><code>Metadata update</code></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Creating a Raw Producer</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">var rawProducer = await streamSystem.CreateRawProducer( // <b class="conum">(1)</b>
    new RawProducerConfig(&quot;my-stream&quot;)
    {
        ConnectionClosedHandler = async reason =&gt; // <b class="conum">(2)</b>
        {
            Console.WriteLine($&quot;Connection closed with reason: {reason}&quot;);
            await Task.CompletedTask.ConfigureAwait(false);
        },
        MetadataHandler = update =&gt; // <b class="conum">(3)</b>
        {
            Console.WriteLine($&quot;Metadata Stream updated: {update.Stream}&quot;);
            return Task.CompletedTask;
        },
        ConfirmHandler = confirmation =&gt; // <b class="conum">(4)</b>
        {
            Console.WriteLine(confirmation.Code == ResponseCode.Ok
                ? $&quot;Message confirmed: {confirmation.PublishingId}&quot;
                : $&quot;Message: {confirmation.PublishingId} not confirmed with error: {confirmation.Code}&quot;);
        }
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create a <code>RawProducer</code> instance</p>
</li>
<li>
<p>Event in case of disconnection</p>
</li>
<li>
<p>Event in case of MetadataHandler update.
This event is triggered by the server when a stream changes topology like deleted or added/removed mirrors</p>
</li>
<li>
<p>ConfirmHandler event.
This event is triggered when a <code>PublishingId</code> message is confirmed by the server with or without an error.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Like the <code>RawProducer</code> class, the <code>Raw*</code> classes have the same events to handle the disconnection and metadata update.</p>
</div>
<div class="paragraph">
<p>It is up to the user to handle the disconnection and metadata update events.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="title">Be careful when using the <code>Raw*</code> classes.</div>
<div class="paragraph">
<p>They are low-level classes and you need to handle the disconnection and metadata update events.
If you don&#8217;t handle them, you will end up with a disconnected client and you will not be able to reconnect to the server.</p>
</div>
<div class="paragraph">
<p>"RawProducer:send" is not thread-safe.
You need to synchronize access to it.
"RawProducer" does not handle the timeout/error confirmation messages.
You need to handle it yourself.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_high_level_classes">High-level classes</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#creating-a-producer"><code>Producer</code></a> - High-level producer class</p>
</li>
<li>
<p><a href="#creating-a-consumer"><code>Consumer</code></a> - High-level consumer class</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Producer</code> and <code>Consumer</code> classes handle auto-reconnection, metadata updates, super-stream and some low-level client behaviour.</p>
</div>
<div class="paragraph">
<p>The <code>Producer</code> traces the sent and received messages to give back to the user the original message sent to the server and also handle the message timeout.
See <a href="#confirmation-status">[confirmation-status]</a> for more details.</p>
</div>
<div class="paragraph">
<p>It would be best to use <code>Producer</code> and <code>Consumer</code> classes unless you need to handle the low-level details.</p>
</div>
<div class="paragraph">
<p>This is a <a href="https://github.com/rabbitmq/rabbitmq-stream-dotnet-client/tree/main/docs/ReliableClient">full example</a> how to deal with disconnections and metadata updates.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_query_streamsuperstream">Query Stream/SuperStream</h4>
<div class="paragraph">
<p>The <code>StreamSytem</code> class expose methods to query a stream or super stream.
The following methods are available:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Valid for</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>QuerySequence(string reference, string stream)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Retrieves the last publishing id for given a producer Reference and stream. Useful for a producer wants to know the last published id.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>QueryOffset(string reference, string stream)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Retrieves retrieves the last consumer offset stored for a given consumer Reference and stream. Useful for as consumer wants to know the last stored offset.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>QueryPartition(string superStream)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the list of stream partitions for a given super stream.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SuperStream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StreamStats(string stream)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the stream statistics:</p>
<p class="tableblock">- <code>FirstOffset()</code>: first offset in the stream</p>
<p class="tableblock">- <code>CommittedChunkId()</code>: the ID (offset) of the committed chunk (block of messages) in the stream.</p>
<p class="tableblock">It is the offset of the first message in the last chunk confirmed by a quorum of the stream cluster members (leader and replicas).</p>
<p class="tableblock">The committed chunk ID is a good indication of what the last offset of a stream can be at a
given time. The value can be stale as soon as the application reads it though, as the committed
chunk ID for a stream that is published to changes all the time.</p>
<p class="tableblock">return committed offset in this stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stream</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="super-streams">Super Streams (Partitioned Streams)</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Super Streams require <strong>RabbitMQ 3.11</strong> or more.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A super stream is a logical stream made of several individual streams.
In essence, a super stream is a partitioned stream that brings scalability compared to a single stream.</p>
</div>
<div class="paragraph">
<p>The stream .NET client uses the same programming model for super streams as with individual streams, that is the <code>Producer</code>, <code>Consumer</code>, <code>Message</code>, etc API are still valid when super streams are in use.
Application code should not be impacted whether it uses individual or super streams.</p>
</div>
<div class="paragraph">
<p>Consuming applications can use super streams and <a href="#single-active-consumer">single active consumer</a> at the same time.
The 2 features combined make sure only one consumer instance consumes from an individual stream at a time.
In this configuration, super streams provide scalability and single active consumer provides the guarantee that messages of an individual stream are processed in order.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="title">Super streams do not deprecate streams</div>
<div class="paragraph">
<p>Super streams are a <a href="https://en.wikipedia.org/wiki/Partition_(database)">partitioning</a> solution.
They are not meant to replace individual streams, they sit on top of them to handle some use cases in a better way.
If the stream data is likely to be large â€“ hundreds of gigabytes or even terabytes, size remains relative â€“ and even presents an obvious partition key (e.g. country), a super stream can be appropriate.
It can help to cope with the data size and to take advantage of data locality for some processing use cases.
Remember that partitioning always comes with complexity though, even if the implementation of super streams strives to make it as transparent as possible for the application developer.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_topology">Topology</h5>
<div class="paragraph">
<p>A super stream is made of several individual streams, so it can be considered a logical entity rather than an actual physical entity.
The topology of a super stream is based on the <a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">AMQP 0.9.1 model</a>, that is exchange, queues, and bindings between them.
This does not mean AMQP resources are used to transport or store stream messages, it means that they are used to <em>describe</em> the super stream topology, that is the streams it is made of.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take the example of an <code>invoices</code> super stream made of 3 streams (i.e. partitions):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>an <code>invoices</code> exchange represents the super stream</p>
</li>
<li>
<p>the <code>invoices-0</code>, <code>invoices-1</code>, <code>invoices-2</code> streams are the partitions of the super stream (streams are also AMQP queues in RabbitMQ)</p>
</li>
<li>
<p>3 bindings between the exchange and the streams link the super stream to its partitions and represent <em>routing rules</em></p>
</li>
</ul>
</div>
<div class="literalblock">
<div class="title">The topology of a super stream is defined with bindings between an exchange and queues</div>
<div class="content">
<pre>                 0    +------------+
               +-----&gt;+ invoicesâ€“0 |
               |      +------------+
+----------+   |
| invoices |   | 1    +------------+
|          +---+-----&gt;+ invoicesâ€“1 |
| exchange |   |      +------------+
+----------+   |
               | 2    +------------+
               +-----&gt;+ invoicesâ€“2 |
                      +------------+</pre>
</div>
</div>
<div class="paragraph">
<p>When a super stream is in use, the stream NET client queries this information to find out about the partitions of a super stream and the routing rules.
From the application code point of view, using a super stream is mostly configuration-based.
Some logic must also be provided to extract routing information from messages.</p>
</div>
</div>
<div class="sect4">
<h5 id="_super_stream_creation">Super Stream Creation</h5>
<div class="paragraph">
<p>It is possible to create the topology of a super stream with any AMQP 0.9.1 library or with the <a href="https://www.rabbitmq.com/management.html">management plugin</a>, but the <code>rabbitmq-streams add_super_stream</code> command is a handy shortcut.
Here is how to create an invoices super stream with 3 partitions:</p>
</div>
<div class="listingblock">
<div class="title">Creating a super stream from the CLI</div>
<div class="content">
<pre>rabbitmq-streams add_super_stream invoices --partitions 3</pre>
</div>
</div>
<div class="paragraph">
<p>Use <code>rabbitmq-streams add_super_stream --help</code> to learn more about the command.</p>
</div>
</div>
<div class="sect4">
<h5 id="super-stream-producer">Publishing to a Super Stream</h5>
<div class="paragraph">
<p>When the topology of a super stream like the one described above has been set, creating a producer for it is straightforward:</p>
</div>
<div class="listingblock">
<div class="title">Creating a Producer for a Super Stream</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">var producer = await Producer.Create(
    new ProducerConfig(system,
            // Costants.StreamName is the Exchange name
            // invoices
            Costants.StreamName) // <b class="conum">(1)</b>
        {
            SuperStreamConfig = new SuperStreamConfig() // <b class="conum">(2)</b>
            {
                // The super stream is enable and we define the routing hashing algorithm
                Routing = msg =&gt; msg.Properties.MessageId.ToString() // <b class="conum">(3)</b>
            }
        }, logger).ConfigureAwait(false);
const int NumberOfMessages = 1_000_000;
for (var i = 0; i &lt; NumberOfMessages; i++)
{
    var message = new Message(Encoding.Default.GetBytes($&quot;my_invoice_number{i}&quot;)) // <b class="conum">(4)</b>
    {
        Properties = new Properties() {MessageId = $&quot;id_{i}&quot;}
    };
    await producer.Send(message).ConfigureAwait(false);</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Configure the <code>Producer</code> with the super stream name</p>
</li>
<li>
<p>Enable the Super Stream mode</p>
</li>
<li>
<p>Provide the logic to get the routing key from a message</p>
</li>
<li>
<p>Send the messages to the super stream</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that even though the <code>invoices</code> super stream is not an actual stream, its name must be used to declare the producer.
Internally the client will figure out the streams that compose the super stream.
The application code must provide the logic to extract a routing key from a message as a <code>Function&lt;Message, String&gt;</code>.
The client will hash the routing key to determine the stream to send the message to (using partition list and a modulo operation).</p>
</div>
<div class="paragraph">
<p>The client uses 32-bit <a href="https://en.wikipedia.org/wiki/MurmurHash">MurmurHash3</a> by default to hash the routing key.
This hash function provides good uniformity and it is compatible with the other clients.</p>
</div>
<div class="sect5">
<h6 id="_resolving_routes_with_bindings">Resolving Routes with Bindings</h6>
<div class="paragraph">
<p>Hashing the routing key to pick a partition is only one way to route messages to the appropriate streams.
The stream .NET client provides another way to resolve streams, based on the routing key <em>and</em> the bindings between the super stream exchange and the streams.</p>
</div>
<div class="paragraph">
<p>This routing strategy makes sense when the partitioning has a business meaning, e.g. with a partition for a region in the world, like in the diagram below:</p>
</div>
<div class="literalblock">
<div class="title">A super stream with a partition for a region in a world</div>
<div class="content">
<pre>                 amer  +---------------+
               +------&gt;+ invoicesâ€“amer |
               |       +---------------+
+----------+   |
| invoices |   | emea  +---------------+
|          +---+------&gt;+ invoicesâ€“emea |
| exchange |   |       +---------------+
+----------+   |
               | apac  +---------------+
               +------&gt;+ invoicesâ€“apac |
                       +---------------+</pre>
</div>
</div>
<div class="paragraph">
<p>To create this topology:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>rabbitmq-streams add_super_stream invoices  --routing-keys apac,emea,amer</code></pre>
</div>
</div>
<div class="paragraph">
<p>In such a case, the routing key will be a property of the message that represents the region:</p>
</div>
<div class="listingblock">
<div class="title">Enabling the "key" routing strategy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">var producer = await Producer.Create(
    new ProducerConfig(system,
            // Costants.StreamName is the Exchange name
            // invoices
            Costants.StreamNameC) 
        {
            SuperStreamConfig = new SuperStreamConfig() 
            {
                // The super stream is enable and we define the routing hashing algorithm
                Routing = msg =&gt; msg.Properties.MessageId.ToString(), // <b class="conum">(1)</b>
                RoutingStrategyType = RoutingStrategyType.Key // <b class="conum">(2)</b>
            }
        }, logger).ConfigureAwait(false);
const int NumberOfMessages = 1_000_000;


for (var i = 0; i &lt; NumberOfMessages; i++)
{
    var key = keys[i % 3];

    var message = new Message(Encoding.Default.GetBytes($&quot;hello{i}&quot;)) 
    {
        Properties = new Properties() {MessageId = $&quot;{key}&quot;}
    };
    await producer.Send(message).ConfigureAwait(false);</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Extract the routing key</p>
</li>
<li>
<p>Enable the "key" routing strategy</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Internally the client will query the broker to resolve the destination streams for a given routing key, making the routing logic from any exchange type available to streams.</p>
</div>
<div class="paragraph">
<p>If there is no binding for a routing key, the client will raise an exception <code>RouteNotFoundException</code>.</p>
</div>
<div class="paragraph">
<p><code>RouteNotFoundException</code> the message is not routed to any stream.</p>
</div>
</div>
<div class="sect5">
<h6 id="super-stream-deduplication">Deduplication</h6>
<div class="paragraph">
<p>Deduplication for a super stream producer works the same way as with a <a href="#outbound-message-deduplication">single stream producer</a>.
The publishing ID values are spread across the streams but this does affect the mechanism.</p>
</div>
<div class="listingblock">
<div class="title">Creating a DeduplicatingProducer for a Super Stream</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">var producer = await DeduplicatingProducer.Create(
    new DeduplicatingProducerConfig(system,
            // Costants.StreamName is the Exchange name
            // invoices
            Costants.StreamName,
            &quot;my-deduplication-producer&quot; // <b class="conum">(1)</b>
        ) // <b class="conum">(1)</b>
        {
            SuperStreamConfig = new SuperStreamConfig() // <b class="conum">(2)</b>
            {
                // The super stream is enable and we define the routing hashing algorithm
                Routing = msg =&gt; msg.Properties.MessageId.ToString() // <b class="conum">(3)</b>
            }
        }).ConfigureAwait(false);
const int NumberOfMessages = 1_000_000;
for (var i = 0; i &lt; NumberOfMessages; i++)
{
    var message = new Message(Encoding.Default.GetBytes($&quot;hello{i}&quot;)) // <b class="conum">(4)</b>
    {
        Properties = new Properties() {MessageId = $&quot;hello{i}&quot;}
    };
    await producer.Send(1, message).ConfigureAwait(false);</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Configure the <code>DeduplicatingProducer</code> with the super stream name and the reference.</p>
</li>
<li>
<p>Enable the Super Stream mode</p>
</li>
<li>
<p>Provide the logic to get the routing key from a message. Send the messages providing the publishing ID.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_consuming_from_a_super_stream">Consuming From a Super Stream</h5>
<div class="paragraph">
<p>A super stream consumer is a composite consumer: it will look up the super stream partitions and create a consumer for each or them.
The programming model is the same as with regular consumers for the application developer: their main job is to provide the application code to process messages, that is a <code>MessageHandler</code> instance.
The configuration is different though and this section covers its subtleties.
But let&#8217;s focus on the behavior of a super stream consumer first.</p>
</div>
<div class="sect5">
<h6 id="super-stream-consumer-in-practice">Super Stream Consumer in Practice</h6>
<div class="paragraph">
<p>Imagine you have a super stream made of 3 partitions (individual streams).
You start an instance of your application, that itself creates a super stream consumer for this super stream.
The super stream consumer will create 3 consumers internally, one for each partition, and messages will flow in your <code>MessageHandler</code>.</p>
</div>
<div class="paragraph">
<p>Imagine now that you start another instance of your application.
It will do the exact same thing as previously and the 2 instances will process the exact same messages in parallel.
This may be not what you want: the messages will be processed twice!</p>
</div>
<div class="paragraph">
<p>Having one instance of your application may be enough: the data are spread across several streams automatically and the messages from the different partitions are processed in parallel from a single OS process.</p>
</div>
<div class="paragraph">
<p>But if you want to scale the processing across several OS processes (or bare-metal machines, or virtual machines) and you don&#8217;t want your messages to be processed several times as illustrated above, you&#8217;ll have to enable the <strong>single active consumer</strong> feature on your super stream consumer.</p>
</div>
<div class="paragraph">
<p>The next subsections cover the basic settings of a super stream consumer and a <a href="#super-stream-sac">dedicated section</a> covers how super stream consumers and single active consumer play together.</p>
</div>
</div>
<div class="sect5">
<h6 id="_declaring_a_super_stream_consumer">Declaring a Super Stream Consumer</h6>
<div class="paragraph">
<p>Declaring a super stream consumer is not much different from declaring a single stream consumer.
The <code>Consumer.Create(..)</code> must be used to set the super stream to consume from:</p>
</div>
<div class="listingblock">
<div class="title">Declaring a super stream consumer</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">var consumer = await Consumer.Create(new ConsumerConfig(system, Costants.StreamName)
{
    IsSuperStream = true, // Mandatory for enabling the super stream // <b class="conum">(1)</b>
    // this is mandatory for super stream single active consumer
    // must have the same ReferenceName for all the consumers
    Reference = &quot;MyApp&quot;,
    OffsetSpec = new OffsetTypeFirst(),
    MessageHandler = async (stream, consumerSource, context, message) =&gt; // <b class="conum">(2)</b>
    {
        loggerMain.LogInformation(&quot;Consumer Name {ConsumerName} &quot; +
                                  &quot;-Received message id: {PropertiesMessageId} body: {S}, Stream {Stream}, Offset {Offset}&quot;,
            consumerName, message.Properties.MessageId, Encoding.UTF8.GetString(message.Data.Contents),
            stream, context.Offset);</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the super stream name</p>
</li>
<li>
<p>Close the consumer when it is no longer necessary</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>That&#8217;s all.
The super stream consumer will take of the details (partitions lookup, coordination of the single consumers, etc).</p>
</div>
</div>
<div class="sect5">
<h6 id="_offset_tracking_2">Offset Tracking</h6>
<div class="paragraph">
<p>The semantic of offset tracking for a super stream consumer are roughly the same as for an individual stream consumer.
There are still some subtle differences, so a good understanding of <a href="#consumer-offset-tracking">offset tracking</a>.</p>
</div>
<div class="paragraph">
<p>The offset tracking is per stream.</p>
</div>
</div>
<div class="sect5">
<h6 id="super-stream-sac">Single Active Consumer Support</h6>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Single Active Consumer requires <strong>RabbitMQ 3.11</strong> or more.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As <a href="#super-stream-consumer-in-practice">stated previously</a>, super stream consumers and single active consumer provide scalability and the guarantee that messages of an individual stream are processed in order.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take an example with a 3-partition super stream:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You have an application that creates a super stream consumer instance with single active consumer enabled.</p>
</li>
<li>
<p>You start 3 instances of this application. An instance in this case is a JVM process, which can be in a Docker container, a virtual machine, or a bare-metal server.</p>
</li>
<li>
<p>As the super stream has 3 partitions, each application instance will create a super stream consumer that maintains internally 3 consumer instances.
That is 9 NET instances of consumer overall.
Such a super stream consumer is a <em>composite consumer</em>.</p>
</li>
<li>
<p>The broker and the different application instances coordinate so that only 1 consumer instance for a given partition receives messages at a time.
So among these 9 consumer instances, only 3 are actually <em>active</em>, the other ones are idle or <em>inactive</em>.</p>
</li>
<li>
<p>If one of the application instances stops, the broker will <em>rebalance</em> its active consumer to one of the other instances.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following figure illustrates how the client library supports the combination of the super stream and single active consumer features.
It uses a composite consumer that creates an individual consumer for each partition of the super stream.
If there is only one single active consumer instance with a given name for a super stream, each individual consumer is active.</p>
</div>
<div class="literalblock">
<div class="title">A single active consumer on a super stream is a composite consumer that creates an individual consumer for each partition</div>
<div class="content">
<pre>              +--------------------+
              |                    |
              |cGRE invoicesâ€“0     |
              |                    |    +-------------------+
              +--------------------+    |+-----------------+|
                                        |+cGRE consumer    ||Active
                                        |+-----------------+|
  invoices    +--------------------+    |                   |
              |                    |    |+-----------------+|
              |cPNK invoicesâ€“1     |    |+cPNK consumer    ||Active
              |                    |    |+-----------------+|
super stream  +--------------------+    |                   |
                                        |+-----------------+|
                                        |+cBLU consumer    ||Active
              +--------------------+    |+-----------------+|
              |                    |    +-------------------+
              |cBLU invoicesâ€“2     |     Composite Consumer
              |                    |
              +--------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>Imagine now we start 3 instances of the consuming application to scale out the processing.
The individual consumer instances spread out across the super stream partitions and only one is active for each partition, as illustrated in the following figure:</p>
</div>
<div class="literalblock">
<div class="title">Consumer instances spread across the super stream partitions and are activated accordingly</div>
<div class="content">
<pre>                                        +-------------------+
                                        |+-----------------+|
                                        |+cGRE consumer    ||Active
                                        |+-----------------+|
                                        |                   |
                                        |+-----------------+|
                                        |+cPNK consumer    ||Inactive
                                        |+-----------------+|
                                        |                   |
                                        |+-----------------+|
                                        |+cBLU consumer    ||Inactive
                                        |+-----------------+|
              +--------------------+    +-------------------+
              |                    |     Composite Consumer
              |cGRE invoicesâ€“0     |
              |                    |    +-------------------+
              +--------------------+    |+-----------------+|
                                        |+cGRE consumer    ||Inactive
                                        |+-----------------+|
  invoices    +--------------------+    |                   |
              |                    |    |+-----------------+|
              |cPNK invoicesâ€“1     |    |+cPNK consumer    ||Active
              |                    |    |+-----------------+|
super stream  +--------------------+    |                   |
                                        |+-----------------+|
                                        |+cBLU consumer    ||Inactive
              +--------------------+    |+-----------------+|
              |                    |    +-------------------+
              |cBLU invoicesâ€“2     |     Composite Consumer
              |                    |
              +--------------------+    +-------------------+
                                        |+-----------------+|
                                        |+cGRE consumer    ||Inactive
                                        |+-----------------+|
                                        |                   |
                                        |+-----------------+|
                                        |+cPNK consumer    ||Inactive
                                        |+-----------------+|
                                        |                   |
                                        |+-----------------+|
                                        |+cBLU consumer    ||Active
                                        |+-----------------+|
                                        +-------------------+
                                         Composite Consumer</pre>
</div>
</div>
<div class="paragraph">
<p>After this overview, let&#8217;s see the API and the configuration details.</p>
</div>
<div class="paragraph">
<p>Note it is mandatory to specify a Reference for the consumer.
This name will be used to identify the <em>group</em> of consumer instances and make sure only one is active for each partition.
The name is also the reference for offset tracking.</p>
</div>
<div class="paragraph">
<p>The example above uses by default <a href="#consumer-manual-offset-tracking">manual offset tracking</a>.
It looks up the latest stored offset when a consumer becomes active to start consuming at the appropriate offset and it stores the last dispatched offset when a consumer becomes inactive.</p>
</div>
<div class="paragraph">
<p>The story is not the same with <a href="#consumer-manual-offset-tracking">manual offset tracking</a> as the client library does not know which offset it should store when a consumer becomes inactive.
The application developer can use the <a href="#consumer-update-listener"><code>ConsumerUpdateListener)</code> callback</a> to react appropriately when a consumer changes state.
The following snippet illustrates the use of the <code>ConsumerUpdateListener</code> callback:</p>
</div>
<div class="listingblock">
<div class="title">Using manual offset tracking for a super stream single active consumer</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c#">    await consumerSource.StoreOffset(context.Offset).ConfigureAwait(false); // <b class="conum">(1)</b>
    await Task.CompletedTask.ConfigureAwait(false);
},
IsSingleActiveConsumer = true, // mandatory for enabling the Single Active Consumer // <b class="conum">(2)</b>
ConsumerUpdateListener = async (reference, stream, isActive) =&gt; // <b class="conum">(3)</b>
{
    loggerMain.LogInformation($&quot;******************************************************&quot;);
    loggerMain.LogInformation(&quot;reference {Reference} stream {Stream} is active: {IsActive}&quot;, reference,
        stream, isActive);

    ulong offset = 0;
    try
    {
        offset = await system.QueryOffset(reference, stream).ConfigureAwait(false);
    }
    catch (OffsetNotFoundException e)
    {
        loggerMain.LogInformation(&quot;OffsetNotFoundException {Message}, will use OffsetTypeNext&quot;, e.Message);
        return new OffsetTypeNext();
    }

    if (isActive)
    {
        loggerMain.LogInformation(&quot;Restart Offset {Offset}&quot;, offset);
    }

    loggerMain.LogInformation($&quot;******************************************************&quot;);
    await Task.CompletedTask.ConfigureAwait(false);
    return new OffsetTypeOffset(offset + 1); // <b class="conum">(4)</b>
},</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Store manually the offset</p>
</li>
<li>
<p>Enable single active consumer</p>
</li>
<li>
<p>Set <code>ConsumerUpdateListener</code></p>
</li>
<li>
<p>Return stored offset + 1 or default when consumer becomes active</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The <code>ConsumerUpdateListener</code> callback must return the offset to start consuming from when a consumer becomes active.
This is what the code above does: it checks if the consumer is active with <code>ConsumerUpdateListener#isActive()</code> and looks up the last stored offset.
If there is no stored offset yet, it returns a default value, <code>OffsetTypeNext()</code> here.</p>
</div>
<div class="paragraph">
<p>When a consumer becomes inactive, it should store the last processed offset, as another consumer instance will take over elsewhere.
It is expected this other consumer runs the exact same code, so it will execute the same sequence when it becomes active (looking up the stored offset, returning the value + 1).</p>
</div>
<div class="paragraph">
<p>Note the <code>ConsumerUpdateListener</code> is called for a <em>partition</em>, that is an individual stream.</p>
</div>
<div class="paragraph">
<p>RabbitMQ Stream provides server-side offset tracking, but it is possible to use an external store to track offsets for streams.
The <code>ConsumerUpdateListener</code> callback is still your friend in this case.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="super-stream-sac-full-example">Super Stream with Single Active Consumer Example</h4>
<div class="paragraph">
<p>You can follow the README on the <a href="https://github.com/rabbitmq/rabbitmq-stream-dotnet-client/tree/main/docs/SuperStream">link</a> to run the Super Stream example with the single active consumer feature.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_advanced_topics">Advanced Topics</h3>
<div class="sect3">
<h4 id="_filtering">Filtering</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Filtering requires <strong>RabbitMQ 3.13</strong> or more and the stream_filter feature flag enabled.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>RabbitMQ Stream provides a server-side filtering feature that avoids reading all the messages of a stream and filtering only on the client side.
This helps to save network bandwidth when a consuming application needs only a subset of messages, e.g. the messages from a given geographical region.</p>
</div>
<div class="paragraph">
<p>The filtering feature works as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>each message is published with an associated <em>filter value</em></p>
</li>
<li>
<p>a consumer that wants to enable filtering must:</p>
<div class="ulist">
<ul>
<li>
<p>define one or several filter values</p>
</li>
<li>
<p>define some client-side filtering logic</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Why does the consumer need to define some client-side filtering logic?
Because the server-side filtering is probabilistic: messages that do not match the filter value(s) can still be sent to the consumer.
The server uses a <a href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom filter</a>, <em>a space-efficient probabilistic data structure</em>, where false positives are possible.
Despite this, the filtering saves some bandwidth, which is its primary goal.</p>
</div>
<div class="sect4">
<h5 id="_filtering_on_the_publishing_side">Filtering on the Publishing Side</h5>
<div class="paragraph">
<p>Filtering on the publishing side consists in defining some logic to extract the filter value from a message.
The following snippet shows how to extract the filter value from an application property:</p>
</div>
<div class="listingblock">
<div class="title">Declaring a producer with logic to extract a filter value from each message</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// This is mandatory for enabling the filter</span>
<span class="predefined-type">Filter</span> = <span class="keyword">new</span> ProducerFilter()
{
    FilterValue = message =&gt; message.ApplicationProperties[<span class="string"><span class="delimiter">&quot;</span><span class="content">state</span><span class="delimiter">&quot;</span></span>].ToString(), // <b class="conum">(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Get filter value from <code>state</code> application property</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note the filter value can be null: the message is then published in a regular way.
It is called in this context an <em>unfiltered</em> message.</p>
</div>
</div>
<div class="sect4">
<h5 id="_filtering_on_the_consuming_side">Filtering on the Consuming Side</h5>
<div class="paragraph">
<p>A consumer needs to set up one or several filter values and some filtering logic to enable filtering.
The filtering logic must be consistent with the filter values.
In the next snippet, the consumer wants to process only messages from the state of <code>Alabama</code>.
It sets a filter value to <code>Alabama</code> and a predicate that accepts a message only if the <code>state</code> application properties is <code>Alabama</code>:</p>
</div>
<div class="listingblock">
<div class="title">Declaring a consumer with a filter value and filtering logic</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">var</span> consumedMessages = <span class="integer">0</span>;
<span class="type">var</span> consumer = await Consumer.Create(<span class="keyword">new</span> ConsumerConfig(system, streamName)
{
    OffsetSpec = <span class="keyword">new</span> OffsetTypeFirst(),

    <span class="comment">// This is mandatory for enabling the filter</span>
    <span class="predefined-type">Filter</span> = <span class="keyword">new</span> ConsumerFilter()
    {
        Values = <span class="keyword">new</span> <span class="predefined-type">List</span>&lt;string&gt;() {<span class="string"><span class="delimiter">&quot;</span><span class="content">Alabama</span><span class="delimiter">&quot;</span></span>}, // <b class="conum">(1)</b>
        PostFilter = message =&gt; message.ApplicationProperties[<span class="string"><span class="delimiter">&quot;</span><span class="content">state</span><span class="delimiter">&quot;</span></span>].Equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">Alabama</span><span class="delimiter">&quot;</span></span>), // <b class="conum">(2)</b>
        MatchUnfiltered = <span class="predefined-constant">true</span>
    },
    MessageHandler = (_, _, _, message) =&gt;
    {
        consumerLogger.LogInformation(<span class="string"><span class="delimiter">&quot;</span><span class="content">Received message with state {State} - consumed {Consumed}</span><span class="delimiter">&quot;</span></span>,
            message.ApplicationProperties[<span class="string"><span class="delimiter">&quot;</span><span class="content">state</span><span class="delimiter">&quot;</span></span>], ++consumedMessages);
        <span class="keyword">return</span> Task.CompletedTask;
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set filter value</p>
</li>
<li>
<p>Set filtering logic</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The filter logic is a <code>Predicate&lt;Message&gt;</code>.
It must return <code>true</code> if a message is accepted.</p>
</div>
<div class="paragraph">
<p>As stated above, not all messages must have an associated filter value.
Many applications may not need some filtering, so they can publish messages the regular way.
So a stream can contain messages with and without an associated filter value.</p>
</div>
<div class="paragraph">
<p>By default, messages without a filter value (a.k.a <em>unfiltered</em> messages) are not sent to a consumer that enabled filtering.</p>
</div>
<div class="paragraph">
<p>But what if a consumer wants to process messages with a filter value and messages without any filter value as well?
It must use the <code>MatchUnfiltered</code> property in its declaration and also make sure to keep the filtering logic consistent.</p>
</div>
</div>
<div class="sect4">
<h5 id="_considerations_on_filtering">Considerations on Filtering</h5>
<div class="paragraph">
<p>As stated previously, the server can send messages that do not match the filter value(s) set by consumers.
This is why application developers must be very careful with the filtering logic they define to avoid processing unwanted messages.</p>
</div>
<div class="paragraph">
<p>What are good candidates for filter values?
Unique identifiers are <em>not</em>: if you know a given message property will be unique in a stream, do not use it as a filter value.
A defined set of values shared across the messages is a good candidate: geographical locations (e.g. countries, states), document types in a stream that stores document information (e.g. payslip, invoice, order), categories of products (e.g. book, luggage, toy).</p>
</div>
<div class="paragraph">
<p>Cardinality of filter values can be from a few to a few thousands.
Extreme cardinality (a couple or dozens of thousands) can make filtering less efficient.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_deal_with_broker_disconnections_reconnections_and_metadata_update_events">Deal with broker disconnections, reconnections and metadata update events</h3>
<div class="paragraph">
<p>The classes <code>Producer</code> and <code>Consumer</code> automatically handle broker disconnections and reconnections.</p>
</div>
<div class="paragraph">
<p>It is important to know what happens when a broker is disconnected and reconnected.
See this <a href="https://docs.google.com/presentation/d/111PccBLRGb-RNpYEKeIm2MQvdky-fXrQ/edit#slide=id.p1">presentation</a> about that.</p>
</div>
<div class="paragraph">
<p>The <code>Producer</code> and <code>Consumer</code> classes also handle metadata update events.
When a stream is deleted, the <code>Producer</code> and <code>Consumer</code> classes automatically close the underlying <code>Raw*Producer</code> and <code>Raw*Consumer</code> objects.</p>
</div>
<div class="paragraph">
<p>The classes provides two interfaces:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ResourceAvailableReconnectStrategy (checks when the resource is available)</p>
</li>
<li>
<p>ReconnectStrategy (reconnects to the broker)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That by default implement the reconnection strategy using a back off algorithm.
You can provide your own implementation of these interfaces to customize the reconnection strategy. Most of the time, the default implementation is enough.</p>
</div>
<div class="paragraph">
<p>You can find a full example <a href="https://github.com/rabbitmq/rabbitmq-stream-dotnet-client/tree/main/docs/ReliableClient">here</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_update_secret">Update Secret</h3>
<div class="paragraph">
<p>To update the secret, you can use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="csharp">await system.UpdateSecret(await NewAccessToken()).ConfigureAwait(false);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see a full example with a Keycloak integration  <a href="https://github.com/rabbitmq/rabbitmq-oauth2-tutorial/tree/main/stream_dot_net/Keycloak">here</a></p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2024-05-24 08:52:16 UTC
</div>
</div>
</body>
</html>