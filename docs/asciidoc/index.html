<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.18">
<title>RabbitMQ Stream .Net Client</title>
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */

@import url("//fonts.googleapis.com/css?family=Noto+Sans:300,600italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700");
@import url(https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css); /* Default asciidoc style framework - important */

/* CUSTOMISATIONS */
/* Change the values in root for quick customisation. If you want even more fine grain... venture further. */

:root{
--maincolor:#FFFFFF;
--primarycolor:#2c3e50;
--secondarycolor:#ba3925;
--tertiarycolor: #186d7a;
--sidebarbackground:#CCC;
--linkcolor:#b71c1c;
--linkcoloralternate:#f44336;
--white:#FFFFFF;
--black:#000000;
}

/* Text styles */
h1{color:var(--primarycolor) !important;}
h2,h3,h4,h5,h6{color:var(--secondarycolor) !important;}
.title{color:var(--tertiarycolor) !important; font-family:"Noto Sans",sans-serif !important;font-style: normal !important; font-weight: normal !important;}
p{font-family: "Noto Sans",sans-serif !important}

/* Table styles */
th{font-family: "Noto Sans",sans-serif !important}

/* Responsiveness fixes */
video {
  max-width: 100%;
}

@media all and (max-width: 600px) {
table {
  width: 55vw!important;
  font-size: 3vw;
}

</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>RabbitMQ Stream .Net Client</h1>
<div class="details">
<span id="revnumber">version {project-version}</span>
<br><span id="revremark">({build-number})</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_what_is_a_rabbitmq_stream">What is a RabbitMQ Stream?</a></li>
<li><a href="#_when_to_use_rabbitmq_stream">When to Use RabbitMQ Stream?</a></li>
<li><a href="#_other_way_to_use_streams_in_rabbitmq">Other Way to Use Streams in RabbitMQ</a></li>
<li><a href="#_guarantees">Guarantees</a></li>
<li><a href="#stream-client-overview">Stream Client Overview</a></li>
<li><a href="#stability-of-programming-interfaces">Stability of Programming Interfaces</a></li>
<li><a href="#low-high-level-classes">Low Level and High Level classes</a></li>
<li><a href="#_the_stream_net_client">The Stream .NET Client</a>
<ul class="sectlevel2">
<li><a href="#_setting_up_rabbitmq">Setting up RabbitMQ</a>
<ul class="sectlevel3">
<li><a href="#_with_docker">With Docker</a>
<ul class="sectlevel4">
<li><a href="#_with_docker_bridge_network_driver">With Docker Bridge Network Driver</a></li>
<li><a href="#_with_docker_host_network_driver">With Docker Host Network Driver</a></li>
</ul>
</li>
<li><a href="#_with_a_rabbitmq_package_running_on_the_host">With a RabbitMQ Package Running on the Host</a></li>
</ul>
</li>
<li><a href="#_dependencies">Dependencies</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The RabbitMQ Stream .Net Client is a .Net library to communicate with
the <a href="https://rabbitmq.com/stream.html">RabbitMQ Stream Plugin</a>.
It allows creating and deleting streams, as well as publishing to and consuming from
these streams. Learn more in the <a href="#stream-client-overview">the client overview</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_a_rabbitmq_stream">What is a RabbitMQ Stream?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A RabbitMQ stream is a persistent and replicated data structure that models
an <a href="https://en.wikipedia.org/wiki/Append-only">append-only log</a>. It differs from the classical
RabbitMQ queue in the way message consumption works. In a classical RabbitMQ queue,
consuming removes messages from the queue. In a RabbitMQ stream, consuming leaves
the stream intact. So the content of a stream can be read and re-read without
impact or destructive effect.</p>
</div>
<div class="paragraph">
<p>None of the stream or classical queue data structure is better than the other,
they are usually suited for different use cases.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_when_to_use_rabbitmq_stream">When to Use RabbitMQ Stream?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RabbitMQ Stream was developed to cover the following messaging use cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Large fan-outs:</em> when several consumer applications need to read the same messages.</p>
</li>
<li>
<p><em>Replay / Time-traveling:</em> when consumer applications need to read the whole
history of data or from a given point in a stream.</p>
</li>
<li>
<p><em>Throughput performance:</em> when higher throughput than with other protocols
(AMQP, STOMP, MQTT) is required.</p>
</li>
<li>
<p><em>Large logs:</em> when large amount of data need to be stored, with minimal
in-memory overhead.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_other_way_to_use_streams_in_rabbitmq">Other Way to Use Streams in RabbitMQ</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is also possible to use the stream abstraction in RabbitMQ
with the AMQP 0-9-1 protocol. Instead of consuming from a stream
with the stream protocol, one consumes from a "stream-powered" queue with
the AMQP 0-9-1 protocol. A "stream-powered" queue is a special type of queue that
is backed up with a stream infrastructure layer and adapted to
provide the stream semantics (mainly non-destructive reading).</p>
</div>
<div class="paragraph">
<p>Using such a queue has the advantage to provide the features
inherent to the stream abstraction (append-only structure, non-destructive
reading) with any AMQP 0-9-1 client library. This is clearly
interesting when considering the maturity of AMQP 0-9-1 client libraries
and the ecosystem around AMQP 0-9-1.</p>
</div>
<div class="paragraph">
<p>But by using it, one does not benefit from the performance
of the stream protocol, which has been designed for performance in mind,
whereas AMQP 0-9-1 is a more general-purpose protocol.</p>
</div>
<div class="paragraph">
<p>See also <a href="https://www.rabbitmq.com/stream-core-plugin-comparison.html">stream-core stream-plugin comparison</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_guarantees">Guarantees</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RabbitMQ stream provides at-least-once guarantees thanks to the
publisher confirm mechanism, which is supported by the stream .NET client.</p>
</div>
<div class="paragraph">
<p>Message <a href="api.html#outbound-message-deduplication">deduplication</a>
is also supported on the publisher side.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="stream-client-overview">Stream Client Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The RabbitMQ Stream .NET Client implements the
<a href="https://github.com/rabbitmq/rabbitmq-server/blob/v3.10.x/deps/rabbitmq_stream/docs/PROTOCOL.adoc">RabbitMQ Stream protocol</a>
and avoids dealing with low-level concerns by providing high-level functionalities
to build fast, efficient, and robust client applications.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>administrate streams (creation/deletion) directly from applications.</em> This
can also be useful for development and testing.</p>
</li>
<li>
<p><em>adapt publishing throughput</em> thanks to the configurable batch size and flow control.</p>
</li>
<li>
<p><em>avoid publishing duplicate messages</em> thanks to message deduplication.</p>
</li>
<li>
<p><em>consume asynchronously from streams and resume where left off</em> thanks to
manual offset tracking.</p>
</li>
<li>
<p><em>enforce <a href="https://blog.rabbitmq.com/posts/2021/07/connecting-to-streams/">best practices</a> to create client connections</em> â€“ to stream leaders for publishers to minimize inter-node traffic and to stream replicas for consumers to offload leaders.</p>
</li>
<li>
<p><em>let the client handle network failure</em> thanks to automatic connection
recovery and automatic re-subscription for consumers.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="stability-of-programming-interfaces">Stability of Programming Interfaces</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The client contains 2 sets of programming interfaces whose stability are of interest for application developers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Application Programming Interfaces (API): those are the ones used to write application logic. They include the interfaces and classes in the <code>RabbitMQ.Stream.Client.Reliable</code> package (e.g. <code>Producer</code>, <code>Consumer</code>, <code>Message</code>). These API constitute the main programming model of the client and will be kept as stable as possible.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="low-high-level-classes">Low Level and High Level classes</h2>
<div class="sectionbody">
<div class="ulist">
<div class="title">NET stream client provides  two types of classes:</div>
<ul>
<li>
<p>Low-level classes</p>
</li>
<li>
<p>High-level classes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>High-level classes (<code>Producer</code> and <code>Consumer</code>) are a wrapper around the Low-Level classes (<code>Raw*Producer</code> and <code>Raw*Consumer</code>)</p>
</div>
<div class="paragraph">
<p><code>Producer</code> and <code>Consumer</code> classes handle auto-reconnection, metadata updates, super-stream and some low-level client behaviour.</p>
</div>
<div class="paragraph">
<p>It would be best to use <code>Producer</code> and <code>Consumer</code> classes unless you need to handle the low-level details.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_stream_net_client">The Stream .NET Client</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The library requires .NET 6 or .NET 7.</p>
</div>
<div class="sect2">
<h3 id="_setting_up_rabbitmq">Setting up RabbitMQ</h3>
<div class="paragraph">
<p>A RabbitMQ 3.9+ node with the stream plugin enabled is required. The easiest way
to get up and running is to use Docker.</p>
</div>
<div class="sect3">
<h4 id="_with_docker">With Docker</h4>
<div class="paragraph">
<p>There are different ways to make the broker visible to the client application when running
in Docker. The next sections show a couple of options suitable for local development.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Docker on macOS</div>
<div class="paragraph">
<p>Docker runs on a virtual machine when using macOS, so do not expect high performance
when using RabbitMQ Stream inside Docker on a Mac.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_with_docker_bridge_network_driver">With Docker Bridge Network Driver</h5>
<div class="paragraph">
<p>This section shows how to start a broker instance for local development
(the broker Docker container and the client application are assumed to run on the
same host).</p>
</div>
<div class="paragraph">
<p>The following command creates a one-time Docker container to run RabbitMQ:</p>
</div>
<div class="listingblock">
<div class="title">Running the stream plugin with Docker</div>
<div class="content">
<pre>docker run -it --rm --name rabbitmq -p 5552:5552 \
    -e RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS='-rabbitmq_stream advertised_host localhost' \
    rabbitmq:3.11</pre>
</div>
</div>
<div class="paragraph">
<p>The previous command exposes only the stream port (5552), you can expose
ports for other protocols:</p>
</div>
<div class="listingblock">
<div class="title">Exposing the AMQP 0.9.1 and management ports:</div>
<div class="content">
<pre>docker run -it --rm --name rabbitmq -p 5552:5552 -p 5672:5672 -p 15672:15672 \
    -e RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS='-rabbitmq_stream advertised_host localhost' \
    rabbitmq:3.11-management</pre>
</div>
</div>
<div class="paragraph">
<p>Refer to the official <a href="https://hub.docker.com/_/rabbitmq">RabbitMQ Docker image web page</a>
to find out more about its usage.</p>
</div>
<div class="paragraph">
<p>Once the container is started, <strong>the stream plugin must be enabled</strong>:</p>
</div>
<div class="listingblock">
<div class="title">Enabling the stream plugin:</div>
<div class="content">
<pre>docker exec rabbitmq rabbitmq-plugins enable rabbitmq_stream</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_with_docker_host_network_driver">With Docker Host Network Driver</h5>
<div class="paragraph">
<p>This is the simplest way to run the broker locally.
The container uses the <a href="https://docs.docker.com/network/host/">host network</a>,
this is perfect for experimenting locally.</p>
</div>
<div class="listingblock">
<div class="title">Running RabbitMQ Stream with the host network driver</div>
<div class="content">
<pre>docker run -it --rm --name rabbitmq --network host rabbitmq:3.11</pre>
</div>
</div>
<div class="paragraph">
<p>Once the container is started, <strong>the stream plugin must be enabled</strong>:</p>
</div>
<div class="listingblock">
<div class="title">Enabling the stream plugin:</div>
<div class="content">
<pre>docker exec rabbitmq rabbitmq-plugins enable rabbitmq_stream</pre>
</div>
</div>
<div class="paragraph">
<p>The container will use the following ports: 5552 (for stream) and 5672 (for AMQP.)</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Docker Host Network Driver Support</div>
<div class="paragraph">
<p>The host networking driver <strong>only works on Linux hosts</strong>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_with_a_rabbitmq_package_running_on_the_host">With a RabbitMQ Package Running on the Host</h4>
<div class="paragraph">
<p>Using a package implies installing Erlang.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Make sure to use <a href="https://github.com/rabbitmq/rabbitmq-server/releases">RabbitMQ 3.9 or more</a>.</p>
</li>
<li>
<p>Follow the steps to
<a href="https://rabbitmq.com/download.html">install Erlang and the appropriate package</a></p>
</li>
<li>
<p>Enable the plugin <code>rabbitmq-plugins enable rabbitmq_stream</code>.</p>
</li>
<li>
<p>The stream plugin listens on port 5552.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Refer to the <a href="https://rabbitmq.com/stream.html">stream plugin documentation</a> for more information on configuration.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dependencies">Dependencies</h3>
<div class="paragraph">
<p>The client is distributed via <a href="https://www.nuget.org/packages/RabbitMQ.Stream.Client/">NuGet</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version {project-version}<br>
Last updated 2023-02-12 11:23:20 UTC
</div>
</div>
</body>
</html>